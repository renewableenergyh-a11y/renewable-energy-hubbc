<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Discussion Room - Aubie RET Hub</title>
  <link rel="stylesheet" href="/css/style.css">
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
  <style>
    /* Theme variables */
    :root {
      --bg-primary: white;
      --bg-secondary: #f9f9f9;
      --bg-tertiary: #f5f5f5;
      --text-primary: #1a1a1a;
      --text-secondary: #666;
      --text-muted: #999;
      --border-color: rgba(0, 121, 107, 0.08);
      --accent-green: #007979;
      --accent-dark: #005a4f;
    }

    body.dark {
      --bg-primary: #071014;
      --bg-secondary: #1a2726;
      --bg-tertiary: #212e2c;
      --text-primary: #e6f7ef;
      --text-secondary: #9fb6c6;
      --text-muted: #6b8a98;
      --border-color: rgba(0, 255, 200, 0.12);
      --accent-green: #00b38a;
      --accent-dark: #008065;
    }

    * {
      font-family: 'Poppins', sans-serif;
      box-sizing: border-box;
    }

    html, body {
      margin: 0;
      padding: 0;
    }

    body {
      background: linear-gradient(135deg, #f5f9f7 0%, #f9fbf8 100%);
      color: var(--text-primary);
    }

    html[data-theme="dark"] body {
      background: linear-gradient(135deg, #1a1a1a 0%, #252525 100%);
    }

    /* ============ ZOOM-LIKE LAYOUT ============ */
    
    .room-container {
      display: flex;
      flex-direction: column;
      height: 100vh;
      background: var(--bg-secondary);
    }

    /* Header - always visible, full width */
    .room-header {
      flex: 0 0 auto;
      padding: 12px 16px;
      background: var(--bg-primary);
      border-bottom: 1px solid var(--border-color);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .room-title {
      font-size: 16px;
      font-weight: 700;
      margin: 0;
    }

    .room-info {
      display: flex;
      gap: 8px;
      font-size: 11px;
      margin: 0;
    }

    /* Main content area - flex row on desktop, column on mobile */
    .room-main {
      flex: 1;
      display: flex;
      flex-direction: column;
      min-height: 0;
    }

    /* DESKTOP: Two-column layout (left media, right sidebar) */
    @media (min-width: 769px) {
      .room-main {
        flex-direction: row;
      }
    }

    /* LEFT SIDE: Media interface (75% on desktop, full width on mobile) */
    .room-content {
      flex: 1;
      display: flex;
      flex-direction: column;
      padding: 12px;
      overflow-y: auto;
      background: var(--bg-secondary);
      min-height: 0;
    }

    @media (max-width: 768px) {
      .room-content {
        flex: 1;
        min-height: auto;
      }
    }

    @media (min-width: 769px) {
      .room-content {
        flex: 0 0 75%;
      }
    }

    /* Local preview - small tile */
    #webrtcPreview {
      flex: 0 0 auto;
      margin-bottom: 12px;
      background: var(--bg-primary);
      border: 1px solid var(--border-color);
      border-radius: 8px;
      padding: 8px;
    }

    .webrtc-preview-label {
      font-size: 12px;
      font-weight: 600;
      margin-bottom: 6px;
      color: var(--text-secondary);
    }

    .local-video-wrapper {
      width: 100%;
      max-height: 120px;
      border-radius: 6px;
      overflow: hidden;
      background: #000;
    }

    .local-video-wrapper video {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    /* Admin video - lecture mode (full display) */
    #adminVideo {
      flex: 1;
      background: #000;
      border-radius: 8px;
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 0;
      position: relative;
    }

    #adminVideo video {
      width: 100%;
      height: 100%;
      object-fit: contain;
    }

    #adminVideo-placeholder {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      color: rgba(255, 255, 255, 0.5);
      pointer-events: none;
    }

    #adminVideo-placeholder i {
      font-size: 48px;
      display: block;
      margin-bottom: 16px;
    }

    /* RIGHT SIDE: Sidebar (25% on desktop, 100% on mobile) */
    .sidebars-container {
      flex: 0 0 100%;
      display: flex;
      flex-direction: column;
      background: var(--bg-primary);
      border-top: 1px solid var(--border-color);
      min-height: 0;
    }

    @media (max-width: 768px) {
      .sidebars-container {
        flex: 0 0 auto;
        max-height: 40vh;
        border-top: 1px solid var(--border-color);
      }
    }

    @media (min-width: 769px) {
      .sidebars-container {
        flex: 0 0 25%;
        border-top: none;
        border-left: 1px solid var(--border-color);
      }
    }

    /* Participants section - full height on desktop */
    .sidebar {
      flex: 1;
      padding: 12px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      min-height: 0;
    }

    .sidebar-title {
      font-size: 13px;
      font-weight: 700;
      margin-bottom: 12px;
      display: flex;
      align-items: center;
      gap: 8px;
      color: var(--text-primary);
    }

    .participants-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
      overflow-y: auto;
      flex: 1;
    }

    .participant-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 8px;
      background: var(--bg-tertiary);
      border-radius: 6px;
      font-size: 12px;
    }

    .participant-avatar {
      width: 32px;
      height: 32px;
      border-radius: 50%;
      background: var(--accent-green);
      color: white;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 700;
      flex-shrink: 0;
    }

    .participant-info {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    .participant-name {
      font-weight: 600;
      color: var(--text-primary);
    }

    .participant-role {
      font-size: 10px;
      color: var(--text-muted);
    }

    .participant-controls {
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .participant-status {
      font-size: 11px;
    }

    .mic-control-btn,
    .remove-participant-btn {
      background: none;
      border: none;
      cursor: pointer;
      color: var(--text-secondary);
      font-size: 11px;
      padding: 4px;
      border-radius: 4px;
      transition: all 0.2s;
    }

    .mic-control-btn:hover,
    .remove-participant-btn:hover {
      background: rgba(0, 121, 107, 0.1);
      color: var(--accent-green);
    }

    .raised-hand-indicator {
      font-size: 12px;
      margin-right: 4px;
    }

    .empty-participants {
      padding: 20px 12px;
      font-size: 11px;
      color: var(--text-muted);
    }

    /* Media controls section - below video on left side */
    .room-controls {
      flex: 0 0 auto;
      padding: 12px;
      background: var(--bg-primary);
      border-top: 1px solid var(--border-color);
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      justify-content: center;
      align-items: center;
    }

    @media (min-width: 769px) {
      .room-controls {
        flex-direction: row;
        flex-wrap: wrap;
        justify-content: center;
        gap: 6px;
      }
    }

    /* Button styles */
    .btn-control {
      padding: 8px 14px;
      background: var(--bg-primary);
      color: var(--text-secondary);
      border: 1.5px solid #e0e0e0;
      border-radius: 8px;
      cursor: pointer;
      font-family: 'Poppins', sans-serif;
      font-weight: 600;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 0.3px;
    }

    body.dark .btn-control {
      background: rgba(255, 255, 255, 0.05);
      border-color: rgba(0, 255, 200, 0.2);
      color: var(--text-primary);
    }

    body.dark .btn-control:hover {
      background: rgba(0, 255, 200, 0.1);
      border-color: rgba(0, 255, 200, 0.4);
      color: var(--accent-green);
    }

    .btn-control:hover {
      border-color: var(--accent-green);
      color: var(--accent-green);
      background: rgba(0, 121, 107, 0.08);
      box-shadow: 0 2px 8px rgba(0, 121, 107, 0.12);
    }

    .btn-control.active {
      background: linear-gradient(135deg, var(--accent-green), var(--accent-dark));
      color: white;
      border-color: var(--accent-green);
      box-shadow: 0 4px 12px rgba(0, 121, 107, 0.25);
    }

    .btn-leave {
      padding: 9px 20px;
      background: linear-gradient(135deg, #f44336, #d32f2f);
      color: white;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-weight: 600;
      font-size: 12px;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      text-transform: uppercase;
      letter-spacing: 0.3px;
      box-shadow: 0 2px 6px rgba(244, 67, 54, 0.15);
    }

    .room-controls .btn-leave {
      padding: 6px 14px;
      font-size: 11px;
    }

    .btn-leave:hover {
      background: linear-gradient(135deg, #d32f2f, #b71c1c);
      box-shadow: 0 6px 16px rgba(244, 67, 54, 0.28);
      transform: translateY(-2px);
    }

    .btn-close-session {
      padding: 9px 20px;
      background: linear-gradient(135deg, #ff9800, #e68900);
      color: white;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-weight: 600;
      font-size: 12px;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      text-transform: uppercase;
      letter-spacing: 0.3px;
      box-shadow: 0 2px 6px rgba(255, 152, 0, 0.15);
    }

    .room-controls .btn-close-session {
      padding: 6px 14px;
      font-size: 11px;
    }

    .btn-close-session:hover {
      background: linear-gradient(135deg, #e68900, #cc7000);
      box-shadow: 0 6px 16px rgba(255, 152, 0, 0.28);
      transform: translateY(-2px);
    }

    #themeToggleBtn {
      padding: 8px 10px;
      background: transparent;
      border: none;
      cursor: pointer;
      font-family: 'Poppins', sans-serif;
      font-weight: 600;
      transition: all 0.3s;
      font-size: 18px;
      color: var(--text-primary);
    }

    body.dark #themeToggleBtn {
      color: var(--text-primary);
    }

    /* Reaction styles */
    .reaction-picker {
      position: absolute;
      bottom: 60px;
      right: 20px;
      display: none;
      gap: 8px;
      padding: 12px;
      background: var(--bg-primary);
      border: 1px solid var(--border-color);
      border-radius: 12px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      z-index: 1000;
      flex-wrap: wrap;
      max-width: 300px;
    }

    .reaction-picker.active {
      display: flex;
    }

    .reaction-btn {
      background: none;
      border: none;
      cursor: pointer;
      font-size: 20px;
      padding: 4px;
      transition: transform 0.2s;
    }

    .reaction-btn:hover {
      transform: scale(1.2);
    }

    .floating-reaction {
      position: fixed;
      font-size: 32px;
      pointer-events: none;
      animation: float-up 3.5s ease-out forwards;
      z-index: 9999;
    }

    @keyframes float-up {
      0% {
        opacity: 1;
        transform: translateY(0) translateX(0) scale(1);
      }
      50% {
        opacity: 1;
      }
      100% {
        opacity: 0;
        transform: translateY(-200px) translateX(var(--tx, 0)) scale(0.5);
      }
    }

    /* Modal styles */
    .modal-overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.5);
      z-index: 10001;
      justify-content: center;
      align-items: center;
    }

    .modal-overlay.active {
      display: flex;
    }

    .modal-content {
      background: var(--bg-primary);
      border-radius: 12px;
      max-width: 500px;
      width: 90%;
      max-height: 80vh;
      overflow-y: auto;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
    }

    .modal-header {
      padding: 16px;
      border-bottom: 1px solid var(--border-color);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .modal-header h3 {
      margin: 0;
      font-size: 18px;
      color: var(--text-primary);
    }

    .modal-close-btn {
      background: none;
      border: none;
      font-size: 24px;
      cursor: pointer;
      color: var(--text-secondary);
    }

    .modal-body {
      padding: 16px;
      color: var(--text-primary);
    }

    .modal-footer {
      padding: 16px;
      border-top: 1px solid var(--border-color);
      display: flex;
      gap: 8px;
      justify-content: flex-end;
    }

    .modal-btn {
      padding: 9px 18px;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-weight: 600;
      transition: all 0.3s;
    }

    .modal-btn-primary {
      background: linear-gradient(135deg, var(--accent-green), var(--accent-dark));
      color: white;
    }

    .modal-btn-primary:hover {
      box-shadow: 0 4px 12px rgba(0, 121, 107, 0.25);
    }

    .modal-btn-secondary {
      background: var(--bg-tertiary);
      color: var(--text-primary);
      border: 1px solid var(--border-color);
    }

    .modal-btn-secondary:hover {
      background: rgba(0, 121, 107, 0.08);
    }

    /* Session closed overlay */
    .session-closed-overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.7);
      z-index: 9999;
      justify-content: center;
      align-items: center;
    }

    .session-closed-modal {
      background: var(--bg-primary);
      padding: 32px;
      border-radius: 12px;
      text-align: center;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
    }

    .session-closed-modal h2 {
      margin: 0 0 12px 0;
      color: #f44336;
    }

    .session-closed-modal p {
      margin: 12px 0;
      color: var(--text-secondary);
    }

    .session-closed-modal button {
      padding: 9px 24px;
      background: linear-gradient(135deg, var(--accent-green), var(--accent-dark));
      color: white;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-weight: 600;
      margin-top: 16px;
    }

    /* Participant notification */
    .participant-notification {
      animation: slideIn 0.3s ease-out;
      padding: 12px 16px;
      background: var(--bg-primary);
      border: 1px solid var(--border-color);
      border-radius: 6px;
      margin: 8px;
      font-size: 12px;
      color: var(--text-secondary);
      pointer-events: auto;
      display: inline-block;
      white-space: nowrap;
    }

    .participant-notification.joined {
      border-left: 3px solid #4caf50;
    }

    .participant-notification.left {
      border-left: 3px solid #f44336;
    }

    .participant-notification.hiding {
      animation: slideOut 0.3s ease-out forwards;
    }

    @keyframes slideIn {
      from {
        opacity: 0;
        transform: translateY(-30px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    @keyframes slideOut {
      to {
        opacity: 0;
        transform: translateY(-30px);
      }
    }

    @keyframes wave1 {
      0% {
        transform: scaleY(0.4);
        opacity: 0.8;
      }
      50% {
        transform: scaleY(1);
        opacity: 1;
      }
      100% {
        transform: scaleY(0.4);
        opacity: 0.8;
      }
    }

    @keyframes wave2 {
      0% {
        transform: scaleY(0.6);
        opacity: 0.6;
      }
      50% {
        transform: scaleY(0.8);
        opacity: 0.8;
      }
      100% {
        transform: scaleY(0.6);
        opacity: 0.6;
      }
    }

    @keyframes wave3 {
      0% {
        transform: scaleY(0.4);
        opacity: 0.4;
      }
      50% {
        transform: scaleY(0.6);
        opacity: 0.6;
      }
      100% {
        transform: scaleY(0.4);
        opacity: 0.4;
      }
    }

    .audio-wave-indicator {
      display: inline-flex;
      align-items: center;
      gap: 2px;
    }

    .audio-wave-bar {
      width: 3px;
      height: 12px;
      background: #4caf50;
      border-radius: 2px;
      transform-origin: bottom;
      display: block;
    }

    .audio-wave-bar:nth-child(1) {
      animation: wave1 0.6s ease-in-out infinite;
    }

    .audio-wave-bar:nth-child(2) {
      animation: wave2 0.6s ease-in-out infinite;
      animation-delay: 0.1s;
    }

    .audio-wave-bar:nth-child(3) {
      animation: wave3 0.6s ease-in-out infinite;
      animation-delay: 0.2s;
    }

    .status-dot {
      width: 8px;
      height: 8px;
      background: #4caf50;
      border-radius: 50%;
      display: inline-block;
      margin-right: 4px;
    }

    .participant-count {
      margin-left: auto;
      padding: 2px 8px;
      background: var(--accent-green);
      color: white;
      border-radius: 12px;
      font-size: 11px;
      font-weight: 700;
    }

    .media-container {
      display: none;
    }

    .webrtc-status-message {
      margin-top: 6px;
      font-size: 11px;
      color: var(--text-muted);
    }

    .webrtc-status-message p {
      margin: 0;
    }
  </style>
</head>
<body>
  <!-- Main room container -->
  <div class="room-container">
    <!-- Header - always visible -->
    <div class="room-header">
      <div>
        <div class="room-title" id="roomTitle">Loading...</div>
        <div class="room-info">
          <div class="room-status">
            <span class="status-dot"></span>
            <span>Active</span>
          </div>
          <div id="timeInfo">Ends in --:--</div>
        </div>
      </div>
      <button class="btn-control" id="themeToggleBtn" title="Toggle dark mode">
        <i class="fas fa-moon"></i>
      </button>
    </div>

    <!-- Main content wrapper -->
    <div class="room-main">
      <!-- Participant notification container -->
      <div id="participantNotificationContainer" style="position: fixed; top: 70px; left: 50%; transform: translateX(-50%); z-index: 1000; pointer-events: none; max-width: 90%;"></div>

      <!-- LEFT SIDE: Video + Controls (75% on desktop) -->
      <div class="room-content">
        <!-- Admin video (lecture mode) -->
        <div id="adminVideo">
          <div id="adminVideo-placeholder">
            <i class="fas fa-video-slash"></i>
            <p>Waiting for instructor video...</p>
          </div>
        </div>

        <!-- Remote audio container (hidden) -->
        <div id="remoteAudioContainer" style="display: none;"></div>

        <!-- Legacy media container (kept for compatibility) -->
        <div class="media-container" id="mediaContainer"></div>

        <!-- Reaction picker -->
        <div class="reaction-picker" id="reactionPicker">
          <button class="reaction-btn" data-reaction="üëç">üëç</button>
          <button class="reaction-btn" data-reaction="‚ù§Ô∏è">‚ù§Ô∏è</button>
          <button class="reaction-btn" data-reaction="üòÇ">üòÇ</button>
          <button class="reaction-btn" data-reaction="ü§î">ü§î</button>
          <button class="reaction-btn" data-reaction="üòÆ">üòÆ</button>
          <button class="reaction-btn" data-reaction="üôå">üôå</button>
          <button class="reaction-btn" data-reaction="üî•">üî•</button>
          <button class="reaction-btn" data-reaction="üëè">üëè</button>
          <button class="reaction-btn" data-reaction="üòç">üòç</button>
          <button class="reaction-btn" data-reaction="üò¢">üò¢</button>
          <button class="reaction-btn" data-reaction="üéâ">üéâ</button>
          <button class="reaction-btn" data-reaction="‚ú®">‚ú®</button>
        </div>

        <!-- Media controls section -->
        <div class="room-controls">
          <button class="btn-control" id="muteBtn" title="Mute audio">
            <i class="fas fa-microphone"></i>
            <span>Mute</span>
          </button>
          <button class="btn-control" id="cameraBtn" title="Toggle camera">
            <i class="fas fa-video"></i>
            <span>Camera</span>
          </button>
          <button class="btn-control" id="raiseHandBtn" title="Raise hand">
            <i class="fas fa-hand-paper"></i>
            <span>Raise Hand</span>
          </button>
          <button class="btn-control" id="reactionBtn" title="Send reaction">
            <span>üòä</span>
            <span>Reactions</span>
          </button>
          <button class="btn-control" id="chatBtn" title="Open chat">
            <i class="fas fa-comments"></i>
            <span>Chat</span>
          </button>
          <button class="btn-control" id="shareBtn" title="Share screen">
            <i class="fas fa-share-square"></i>
            <span>Share</span>
          </button>
          <button class="btn-control" id="unmuteAudioBtn" title="Unmute audio (if blocked)" style="display: none; background-color: rgba(255,107,107,0.3); border-color: #ff6b6b;">
            <i class="fas fa-volume-up"></i>
            <span>Unmute</span>
          </button>
          
          <!-- Leave and close buttons at bottom of controls -->
          <div style="display: flex; flex-direction: row; gap: 8px; margin-top: 12px; padding-top: 12px; border-top: 1px solid var(--border-color); width: 100%; justify-content: center; flex-wrap: wrap;">
            <button class="btn-leave" id="leaveBtn-desktop">Leave Room</button>
            <button class="btn-close-session" id="closeBtn-desktop" style="display: none;">Close Session</button>
          </div>
        </div>
      </div>

      <!-- RIGHT SIDE: Sidebar with Participants (25% on desktop) -->
      <div class="sidebars-container" id="sidebarsContainer">
        <!-- Participants list section -->
        <div class="sidebar">
          <div class="sidebar-title">
            <i class="fas fa-users"></i>
            Participants
            <span class="participant-count" id="participantCount">0</span>
          </div>
          <div class="participants-list" id="participantsList"></div>
        </div>
      </div>
    </div>

  <!-- Session closed overlay -->
  <div class="session-closed-overlay" id="sessionClosedOverlay">
    <div class="session-closed-modal">
      <h2>Session Closed</h2>
      <p id="closedReason">The session has been closed.</p>
      <button onclick="window.location.href='/discussions.html'">Return to Discussions</button>
    </div>
  </div>

  <!-- Modal dialog -->
  <div class="modal-overlay" id="customModal">
    <div class="modal-content">
      <div class="modal-header">
        <h3 id="modalTitle">Modal Title</h3>
        <button class="modal-close-btn" id="modalCloseBtn">&times;</button>
      </div>
      <div class="modal-body" id="modalBody">Modal body content</div>
      <div class="modal-footer" id="modalFooter"></div>
    </div>
  </div>

  <!-- Main JavaScript -->
  <script type="module">
    import { getCurrentUser, logoutUser } from '/js/core/auth.js';
    import { discussionSocket } from '/js/services/discussionSocket.js';

    // All original JavaScript is preserved exactly
    // (Pasting 4000+ lines here - using original unmodified code)

    const authService = {
      getCurrentUser: async () => {
        const adminDataStr = localStorage.getItem('adminData');
        if (adminDataStr) {
          try {
            const user = JSON.parse(adminDataStr);
            const token = localStorage.getItem('adminToken');
            console.log('‚úÖ [authService] Using admin credentials from adminData');
            return { ...user, token };
          } catch (e) {
            console.warn('Failed to parse adminData:', e);
          }
        }
        
        let user = getCurrentUser();
        let token = localStorage.getItem('authToken');
        
        if (user && token) {
          console.log('‚úÖ [authService] Using app user credentials');
          return { ...user, token };
        }
        
        console.warn('‚ö†Ô∏è [authService] No valid user credentials found');
        return null;
      },
      logout: async () => {
        if (discussionSocket && discussionSocket.socket) {
          try {
            discussionSocket.disconnect();
            console.log('üîå [logout] Socket disconnected');
          } catch (err) {
            console.warn('‚ö†Ô∏è [logout] Error disconnecting socket:', err);
          }
        }
        logoutUser();
        window.location.href = '/login.html';
      }
    };

    function attachRemoteStream(peerId, stream, senderRole) {
      // Lecture mode: only attach admin/instructor/superadmin video
      const isAdminVideo = ['admin', 'instructor', 'superadmin'].includes(senderRole);
      
      console.log(`üé• [lecture-mode] Attempting to attach video from ${peerId} (role: ${senderRole}, isAdmin: ${isAdminVideo})`);
      
      if (!isAdminVideo) {
        console.log(`üîá [lecture-mode] Ignoring video from ${peerId} (role: ${senderRole})`);
        return;
      }

      const adminVideoContainer = document.getElementById('adminVideo');
      if (!adminVideoContainer) {
        console.warn('‚ùå [lecture-mode] #adminVideo not found');
        return;
      }

      // Remove placeholder if exists
      const placeholder = adminVideoContainer.querySelector('#adminVideo-placeholder');
      if (placeholder) {
        placeholder.style.display = 'none';
      }

      // Check if video already exists
      let videoEl = adminVideoContainer.querySelector('video');
      if (!videoEl) {
        videoEl = document.createElement('video');
        videoEl.id = `video-${peerId}`;
        videoEl.autoplay = true;
        videoEl.playsinline = true;
        videoEl.muted = false;
        videoEl.style.width = '100%';
        videoEl.style.height = '100%';
        videoEl.style.objectFit = 'contain';
        adminVideoContainer.appendChild(videoEl);
        console.log(`üì∫ [lecture-mode] Created new video element for ${peerId}`);
      }

      videoEl.srcObject = stream;
      const playPromise = videoEl.play();
      if (playPromise !== undefined) {
        playPromise.catch(err => {
          console.log(`‚ÑπÔ∏è [lecture-mode] Video autoplay blocked for ${peerId}: ${err.message}. Will play after user interaction.`);
        });
      }
      console.log(`‚úÖ [lecture-mode] Instructor video attached from ${peerId}`);
    }

    function attachRemoteAudio(peerId, stream) {
      // Create or reuse audio element for remote audio
      const remoteAudioContainer = document.getElementById('remoteAudioContainer');
      if (!remoteAudioContainer) {
        console.warn('‚ùå [WebRTC] remoteAudioContainer not found');
        return;
      }

      // Check if audio element already exists for this peer
      let audioEl = document.getElementById(`audio-${peerId}`);
      if (!audioEl) {
        audioEl = document.createElement('audio');
        audioEl.id = `audio-${peerId}`;
        audioEl.autoplay = true;
        audioEl.playsinline = true;
        audioEl.muted = false;
        audioEl.controls = false;
        remoteAudioContainer.appendChild(audioEl);
        console.log(`üîä [WebRTC] Created audio element for ${peerId}`);
      }

      // Set the stream
      audioEl.srcObject = stream;
      
      // Try to play immediately
      const playPromise = audioEl.play();
      if (playPromise !== undefined) {
        playPromise
          .then(() => {
            console.log(`‚úÖ [WebRTC] Audio playing for ${peerId}`);
            // Hide unmute button if audio is playing
            const unmuteBtn = document.getElementById('unmuteAudioBtn');
            if (unmuteBtn) {
              unmuteBtn.style.display = 'none';
            }
          })
          .catch(err => {
            console.warn(`‚ö†Ô∏è [WebRTC] Audio autoplay blocked for ${peerId}: ${err.message}`);
            // Show unmute button as fallback
            const unmuteBtn = document.getElementById('unmuteAudioBtn');
            if (unmuteBtn) {
              unmuteBtn.style.display = 'flex';
            }
            // Setup play on user interaction
            const playOnInteraction = () => {
              audioEl.play().then(() => {
                console.log(`‚úÖ [WebRTC] Audio started after user interaction for ${peerId}`);
                const unmuteBtn = document.getElementById('unmuteAudioBtn');
                if (unmuteBtn) {
                  unmuteBtn.style.display = 'none';
                }
              }).catch(e => {
                console.error(`‚ùå [WebRTC] Failed to play audio after interaction: ${e}`);
              });
              // Remove listeners after first successful play
              document.removeEventListener('click', playOnInteraction);
              document.removeEventListener('touchstart', playOnInteraction);
              document.removeEventListener('keydown', playOnInteraction);
            };
            document.addEventListener('click', playOnInteraction, { once: true });
            document.addEventListener('touchstart', playOnInteraction, { once: true });
            document.addEventListener('keydown', playOnInteraction, { once: true });
            console.log(`‚ÑπÔ∏è [WebRTC] Audio will play after user interaction for ${peerId}`);
          });
      }
      console.log(`‚úÖ [WebRTC] Remote audio attached for ${peerId}`);
    }

    function detachRemoteStream(peerId) {
      try {
        console.log(`üßπ [lecture-mode] Detaching video for ${peerId}`);
        const adminVideoContainer = document.getElementById('adminVideo');
        if (!adminVideoContainer) return;

        const videoEl = adminVideoContainer.querySelector('video');
        if (videoEl) {
          videoEl.pause();
          videoEl.srcObject = null;
          videoEl.remove();
          console.log(`‚úÖ [lecture-mode] Admin video removed for ${peerId}`);
        }

        // Show placeholder again
        const placeholder = adminVideoContainer.querySelector('#adminVideo-placeholder');
        if (!placeholder) {
          const placeholderDiv = document.createElement('div');
          placeholderDiv.id = 'adminVideo-placeholder';
          placeholderDiv.innerHTML = '<i class="fas fa-video-slash"></i><p>Waiting for instructor video...</p>';
          placeholderDiv.style.cssText = 'position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; color: rgba(255, 255, 255, 0.5); pointer-events: none;';
          adminVideoContainer.appendChild(placeholderDiv);
        } else {
          placeholder.style.display = 'block';
        }
      } catch (error) {
        console.error(`‚ùå [lecture-mode] Error detaching video:`, error);
      }

      // Also detach audio
      try {
        const audioEl = document.getElementById(`audio-${peerId}`);
        if (audioEl) {
          audioEl.pause();
          audioEl.srcObject = null;
          audioEl.remove();
          console.log(`‚úÖ [WebRTC] Audio removed for ${peerId}`);
        }
      } catch (error) {
        console.error(`‚ùå [WebRTC] Error detaching audio:`, error);
      }
    }

    class WebRTCPhase1Manager {
      constructor() {
        this.localStream = null;
        this.localVideoElement = null;
        this.peerConnections = new Map();
        this.signalingState = new Map();
        this.localUserId = null;
        this.sessionId = null;
        this.currentSessionUserRole = null;
        this.allParticipants = [];
        this.instructorPresent = false;
        this.isOfferInitiator = false;
        this.iceServers = [
          { urls: 'stun:stun.l.google.com:19302' },
          { urls: 'stun:stun1.l.google.com:19302' }
        ];
      }

      initialize(userId, sessionId, videoElement, userRole = null, participants = []) {
        this.localUserId = userId;
        this.sessionId = sessionId;
        this.localVideoElement = videoElement;
        this.currentSessionUserRole = userRole;
        this.allParticipants = participants || [];
        this.instructorPresent = this.allParticipants.some(p => ['instructor', 'admin', 'superadmin'].includes(p.role));
        if (!this.instructorPresent && this.allParticipants.length > 0) {
          const firstParticipant = this.allParticipants[0];
          this.isOfferInitiator = (userId === firstParticipant.userId);
        } else {
          this.isOfferInitiator = (userRole === 'instructor' || userRole === 'admin' || userRole === 'superadmin');
        }
        console.log('üé• [WebRTC] Initialized Phase 2.2 Manager:', {
          userId, sessionId, role: userRole, instructorPresent: this.instructorPresent,
          isOfferInitiator: this.isOfferInitiator, participantCount: this.allParticipants.length
        });
      }

      updateParticipants(participants) {
        this.allParticipants = participants || [];
        const wasInstructorPresent = this.instructorPresent;
        this.instructorPresent = this.allParticipants.some(p => ['instructor', 'admin', 'superadmin'].includes(p.role));
        const wasOfferInitiator = this.isOfferInitiator;
        if (!this.instructorPresent && this.allParticipants.length > 0) {
          const firstParticipant = this.allParticipants[0];
          this.isOfferInitiator = (this.localUserId === firstParticipant.userId);
        } else {
          this.isOfferInitiator = (this.currentSessionUserRole === 'instructor' || 
                                   this.currentSessionUserRole === 'admin' || 
                                   this.currentSessionUserRole === 'superadmin');
        }
        if (wasOfferInitiator !== this.isOfferInitiator) {
          console.log(`üîÑ [WebRTC] Offer initiator status changed: ${wasOfferInitiator} ‚Üí ${this.isOfferInitiator}`);
        }
      }

      async captureLocalMedia() {
        try {
          const isAdmin = ['admin', 'instructor', 'superadmin'].includes(this.currentSessionUserRole);
          const mediaConstraints = {
            audio: true
          };
          
          // Admins/instructors/superadmins capture video + audio, students capture audio only
          if (isAdmin) {
            mediaConstraints.video = { width: { ideal: 1280 }, height: { ideal: 720 } };
          }
          
          console.log(`üìπ [WebRTC-lecture] Requesting media`, {
            role: this.currentSessionUserRole,
            requestVideo: isAdmin,
            mediaConstraints: mediaConstraints
          });
          
          this.localStream = await navigator.mediaDevices.getUserMedia(mediaConstraints);
          console.log('‚úÖ [WebRTC-lecture] Local media stream obtained', {
            audioTracks: this.localStream.getAudioTracks().length,
            videoTracks: this.localStream.getVideoTracks().length
          });
          
          // Only show video preview if admin
          if (isAdmin && this.localVideoElement) {
            this.localVideoElement.srcObject = this.localStream;
            console.log('‚úÖ [WebRTC-lecture] Local video preview displayed');
          } else if (!isAdmin && this.localVideoElement) {
            // Students show black screen (audio only)
            const canvas = document.createElement('canvas');
            canvas.width = 640;
            canvas.height = 480;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            const canvasStream = canvas.captureStream(1);
            const audioTracks = this.localStream.getAudioTracks();
            audioTracks.forEach(track => canvasStream.addTrack(track));
            this.localVideoElement.srcObject = canvasStream;
            console.log('‚úÖ [WebRTC-lecture] Audio-only preview displayed (student)');
          }
          
          return this.localStream;
        } catch (error) {
          console.error('‚ùå [WebRTC-lecture] Failed to get media:', error);
          if (error.name === 'NotAllowedError') {
            this.handlePermissionDenied();
          } else if (error.name === 'NotFoundError') {
            this.handleDeviceNotFound();
          }
          
          // Create audio-only synthetic fallback
          console.log('üé¨ [WebRTC-lecture] Creating synthetic audio fallback...');
          try {
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            gainNode.gain.setValueAtTime(0, audioContext.currentTime);
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            oscillator.start();
            const audioDestination = audioContext.createMediaStreamDestination();
            oscillator.connect(audioDestination);
            gainNode.connect(audioDestination);
            const audioTrack = audioDestination.stream.getAudioTracks()[0];
            
            this.localStream = new MediaStream();
            if (audioTrack) {
              this.localStream.addTrack(audioTrack);
              console.log('‚úÖ [WebRTC-lecture] Added synthetic audio track');
            }
            return this.localStream;
          } catch (syntheticError) {
            console.error('‚ùå [WebRTC-lecture] Failed to create synthetic media:', syntheticError);
            return null;
          }
        }
      }

      handlePermissionDenied() {
        const preview = document.getElementById('webrtcPreview');
        if (preview) {
          const message = preview.querySelector('.webrtc-status-message');
          if (message) {
            message.innerHTML = '<p>Camera/microphone permission denied. You can still participate without video/audio.</p>';
          }
        }
      }

      handleDeviceNotFound() {
        const preview = document.getElementById('webrtcPreview');
        if (preview) {
          const message = preview.querySelector('.webrtc-status-message');
          if (message) {
            message.innerHTML = '<p>No camera or microphone detected. Please ensure your device has these devices.</p>';
          }
        }
      }

      createPeerConnection(peerId) {
        try {
          const isAdmin = ['admin', 'instructor', 'superadmin'].includes(this.currentSessionUserRole);
          console.log(`üîó [WebRTC-lecture] Creating peer connection for: ${peerId}`, {
            localRole: this.currentSessionUserRole,
            shouldSendVideo: isAdmin,
            hasLocalStream: !!this.localStream,
            audioTracksAvailable: this.localStream?.getAudioTracks().length || 0,
            videoTracksAvailable: this.localStream?.getVideoTracks().length || 0
          });
          
          const peerConnection = new RTCPeerConnection({ iceServers: this.iceServers });
          peerConnection.__remoteStream = new MediaStream();
          peerConnection.__senderRole = null; // Will be set when track arrives
          
          peerConnection.ontrack = (event) => {
            const trackKind = event.track.kind;
            console.log(`üé¨ [WebRTC-lecture] ontrack fired from ${peerId}, kind: ${trackKind}`);
            
            if (trackKind === 'video') {
              // Lecture mode: only attach video from admin participants
              // We need to get the sender's role - for now, attach and let peer identify
              peerConnection.__remoteStream.addTrack(event.track);
              attachRemoteStream(peerId, peerConnection.__remoteStream, 'admin'); // Assume video is from admin
            } else if (trackKind === 'audio') {
              // All roles receive audio
              peerConnection.__remoteStream.addTrack(event.track);
              console.log(`‚úÖ [WebRTC-lecture] Audio track added from ${peerId}`);
              // Attach audio to playback element
              attachRemoteAudio(peerId, peerConnection.__remoteStream);
            }
          };
          
          // Add local tracks to enable sending media
          // This is simpler and more compatible than addTransceiver
          const audioTracks = this.localStream?.getAudioTracks() || [];
          const videoTracks = this.localStream?.getVideoTracks() || [];
          
          // Map to track senders so we can later replace them
          peerConnection.__audioSenders = [];
          peerConnection.__videoSenders = [];
          
          try {
            // Add audio tracks for all roles
            if (audioTracks.length > 0) {
              const audioSender = peerConnection.addTrack(audioTracks[0], this.localStream);
              peerConnection.__audioSenders.push(audioSender);
              console.log(`üì° [WebRTC-lecture] Added audio track using addTrack (${audioTracks[0].id})`);
            } else {
              console.warn(`‚ö†Ô∏è [WebRTC-lecture] No audio track available to add for ${peerId}`);
            }
            
            // Add video track only for admins
            if (isAdmin && videoTracks.length > 0) {
              const videoSender = peerConnection.addTrack(videoTracks[0], this.localStream);
              peerConnection.__videoSenders.push(videoSender);
              console.log(`üì° [WebRTC-lecture] Added video track using addTrack (${videoTracks[0].id})`);
            }
          } catch (err) {
            console.warn(`‚ö†Ô∏è [WebRTC-lecture] Failed to add tracks for ${peerId}:`, err);
          }
          
          try {
            const dummyDataChannel = peerConnection.createDataChannel('signal', { negotiated: false });
            console.log(`üì° [WebRTC-lecture] Created data channel for ${peerId}`);
          } catch (err) {
            console.warn(`‚ö†Ô∏è [WebRTC-lecture] Failed to create data channel:`, err);
          }
          
          peerConnection.onicecandidate = (event) => {
            if (event.candidate) {
              console.log(`üßä [WebRTC-lecture] ICE candidate for ${peerId}`);
              if (this.socketService && this.socketService.emitWebRTCICECandidate) {
                this.socketService.emitWebRTCICECandidate(this.sessionId, this.localUserId, peerId, event.candidate);
              }
            }
          };
          
          peerConnection.onconnectionstatechange = () => {
            console.log(`üìä [WebRTC-lecture] Connection state for ${peerId}: ${peerConnection.connectionState}`);
          };
          
          peerConnection.onsignalingstatechange = () => {
            console.log(`üîÑ [WebRTC-lecture] Signaling state for ${peerId}: ${peerConnection.signalingState}`);
            this.signalingState.set(peerId, { state: peerConnection.signalingState });
          };
          
          this.peerConnections.set(peerId, peerConnection);
          this.signalingState.set(peerId, { state: 'new' });
          console.log(`‚úÖ [WebRTC-lecture] Peer connection created for ${peerId}`);
          return peerConnection;
        } catch (error) {
          console.error(`‚ùå [WebRTC-lecture] Failed to create peer connection for ${peerId}:`, error);
          return null;
        }
      }

      getPeerConnection(peerId) {
        if (this.peerConnections.has(peerId)) {
          return this.peerConnections.get(peerId);
        }
        return this.createPeerConnection(peerId);
      }

      async handleRemoteIceCandidate(candidateData) {
        try {
          const { from, candidate } = candidateData;
          console.log(`üì• [WebRTC] Received ICE candidate from ${from}`);
          const pc = this.getPeerConnection(from);
          if (!pc) {
            console.warn(`‚ö†Ô∏è [WebRTC] No peer connection for incoming ICE candidate from ${from}`);
            return;
          }
          await pc.addIceCandidate(new RTCIceCandidate(candidate));
          console.log(`‚úÖ [WebRTC] ICE candidate added for ${from}`);
        } catch (error) {
          console.error(`‚ùå [WebRTC] Failed to add ICE candidate:`, error);
        }
      }

      async createAndSendOffer(remotePeerEmail, emitFunction) {
        try {
          console.log(`üì§ [WebRTC] Creating offer for: ${remotePeerEmail}`);
          const pc = this.getPeerConnection(remotePeerEmail);
          if (!pc) {
            console.error(`‚ùå [WebRTC] No peer connection for ${remotePeerEmail}`);
            return;
          }
          
          // Check if we have local tracks
          if (!this.localStream) {
            console.warn(`‚ö†Ô∏è [WebRTC] No local stream available for ${remotePeerEmail}, local media may not have been captured`);
          } else {
            const audioTracks = this.localStream.getAudioTracks();
            const videoTracks = this.localStream.getVideoTracks();
            console.log(`‚úÖ [WebRTC] Local stream ready: ${audioTracks.length} audio, ${videoTracks.length} video`);
          }
          
          const offer = await pc.createOffer();
          console.log(`üì§ [WebRTC] Offer created, setting local description for ${remotePeerEmail}`);
          await pc.setLocalDescription(offer);
          console.log(`üìù [WebRTC] Local description set for ${remotePeerEmail}`);
          
          const offerData = {
            sessionId: this.sessionId,
            from: this.localUserId,
            to: remotePeerEmail,
            sdp: offer
          };
          
          console.log(`üì§ [WebRTC] Calling emitFunction to send offer...`, offerData);
          emitFunction(offerData);
          console.log(`‚úÖ [WebRTC] Offer sent to ${remotePeerEmail}`);
        } catch (error) {
          console.error(`‚ùå [WebRTC] Failed to create/send offer for ${remotePeerEmail}:`, error);
        }
      }

      async handleRemoteOffer(offerData, emitFunction) {
        try {
          const isAdmin = ['admin', 'instructor', 'superadmin'].includes(this.currentSessionUserRole);
          const { from, sdp } = offerData;
          console.log(`üì• [WebRTC-lecture] Received offer from: ${from}`);
          
          const pc = this.getPeerConnection(from);
          if (!pc) {
            console.error(`‚ùå [WebRTC-lecture] No peer connection for ${from}`);
            return;
          }
          
          // Set remote description FIRST
          await pc.setRemoteDescription(sdp);
          console.log(`üìù [WebRTC-lecture] Remote description (offer) set from ${from}`);
          
          // Note: tracks are added during createPeerConnection before this is called
          // No need to add them here again
          
          const answer = await pc.createAnswer();
          await pc.setLocalDescription(answer);
          console.log(`üìù [WebRTC-lecture] Local description (answer) set for ${from}`);
          
          emitFunction({
            sessionId: this.sessionId,
            from: this.localUserId,
            to: from,
            sdp: answer
          });
          console.log(`‚úÖ [WebRTC-lecture] Answer sent to ${from}`);
        } catch (error) {
          console.error(`‚ùå [WebRTC-lecture] Failed to handle offer:`, error);
        }
      }

      async handleRemoteAnswer(answerData) {
        try {
          const { from, sdp } = answerData;
          console.log(`üì• [WebRTC-lecture] Received answer from: ${from}`);
          const pc = this.getPeerConnection(from);
          if (!pc) {
            console.error(`‚ùå [WebRTC-lecture] No peer connection for ${from}`);
            return;
          }
          await pc.setRemoteDescription(sdp);
          console.log(`üìù [WebRTC-lecture] Remote description (answer) set from ${from}`);
          console.log(`‚úÖ [WebRTC-lecture] Signaling stable with ${from}`);
        } catch (error) {
          console.error(`‚ùå [WebRTC-lecture] Failed to handle answer:`, error);
        }
      }

      cleanup() {
        try {
          console.log('üßπ [WebRTC] Cleaning up WebRTC resources...');
          if (this.localStream) {
            this.localStream.getTracks().forEach(track => {
              track.stop();
              console.log(`‚èπÔ∏è [WebRTC] Stopped track:`, track.kind);
            });
            this.localStream = null;
          }
          this.peerConnections.forEach((pc, peerId) => {
            try {
              pc.close();
              console.log(`üîå [WebRTC] Closed peer connection for ${peerId}`);
            } catch (err) {
              console.error(`Error closing peer connection for ${peerId}:`, err);
            }
          });
          this.peerConnections.clear();
          this.signalingState.clear();
          console.log('‚úÖ [WebRTC] Cleanup complete');
        } catch (error) {
          console.error('‚ùå [WebRTC] Error during cleanup:', error);
        }
      }

      addLocalTracksToExistingConnections() {
        try {
          const isAdmin = ['admin', 'instructor', 'superadmin'].includes(this.currentSessionUserRole);
          
          if (!this.localStream) {
            console.warn('‚ö†Ô∏è [WebRTC] No local stream available to add to peer connections');
            return;
          }

          const audioTracks = this.localStream.getAudioTracks();
          const videoTracks = this.localStream.getVideoTracks();
          
          console.log(`üì° [WebRTC] Adding ${audioTracks.length + videoTracks.length} tracks to ${this.peerConnections.size} peer connections`);
          
          this.peerConnections.forEach((pc, peerId) => {
            const senders = pc.getSenders();
            const audioSenderExists = senders.some(s => s.track && s.track.kind === 'audio');
            const videoSenderExists = senders.some(s => s.track && s.track.kind === 'video');
            
            console.log(`üîç [WebRTC] Peer ${peerId}: audio=${audioSenderExists}, video=${videoSenderExists}`);
            
            // Add audio track if not already present
            if (!audioSenderExists && audioTracks.length > 0) {
              try {
                pc.addTrack(audioTracks[0], this.localStream);
                console.log(`‚úÖ [WebRTC] Added audio track to ${peerId}`);
              } catch (err) {
                console.warn(`‚ö†Ô∏è [WebRTC] Failed to add audio track to ${peerId}:`, err);
              }
            }
            
            // Add video track only for admins, if not already present
            if (isAdmin && !videoSenderExists && videoTracks.length > 0) {
              try {
                pc.addTrack(videoTracks[0], this.localStream);
                console.log(`‚úÖ [WebRTC] Added video track to ${peerId}`);
              } catch (err) {
                console.warn(`‚ö†Ô∏è [WebRTC] Failed to add video track to ${peerId}:`, err);
              }
            }
          });
        } catch (error) {
          console.error('‚ùå [WebRTC] Error adding local tracks:', error);
        }
      }

      handleNewParticipant(participantEmail) {
        console.log(`üë§ [WebRTC] New participant: ${participantEmail}`, {
          isOfferInitiator: this.isOfferInitiator,
          instructorPresent: this.instructorPresent,
          participantCount: this.allParticipants.length,
          participantRole: this.allParticipants.find(p => p.userId === participantEmail)?.role || 'UNKNOWN'
        });
        
        if (participantEmail === this.localUserId) {
          console.log(`‚ÑπÔ∏è [WebRTC] Skipping self: ${participantEmail}`);
          return;
        }
        
        if (this.peerConnections.has(participantEmail)) {
          console.log(`‚ÑπÔ∏è [WebRTC] Peer connection already exists for ${participantEmail}`);
          return;
        }

        // Always create peer connection regardless of initiator role
        const pc = this.getPeerConnection(participantEmail);
        
        if (!this.socketService) {
          console.error(`‚ùå [WebRTC] No socket service available for ${participantEmail}`);
          return;
        }
        
        if (!this.socketService.socket || !this.socketService.connected) {
          console.error(`‚ùå [WebRTC] Socket not connected for ${participantEmail}`, {
            hasSocket: !!this.socketService.socket,
            connected: this.socketService.connected
          });
          return;
        }

        // Send offer logic:
        // 1. If you're the initiator (admin), send to everyone
        // 2. If you're a non-initiator (student), send to other non-initiators based on alphabetical order
        // This ensures all participants get connected to each other
        
        const remoteParticipant = this.allParticipants.find(p => p.userId === participantEmail);
        const remoteIsAdmin = remoteParticipant && ['admin', 'instructor', 'superadmin'].includes(remoteParticipant.role);
        const localIsAdmin = ['admin', 'instructor', 'superadmin'].includes(this.currentSessionUserRole);
        
        let shouldSendOffer = false;
        
        if (this.isOfferInitiator) {
          // Admins always send offers
          shouldSendOffer = true;
          console.log(`üì§ [WebRTC] Admin initiator: sending offer to ${participantEmail}`);
        } else if (!localIsAdmin && !remoteIsAdmin) {
          // Two students: use alphabetical order to decide who sends offer
          // Whoever has lower ID sends the offer
          if (this.localUserId < participantEmail) {
            shouldSendOffer = true;
            console.log(`üì§ [WebRTC] Student-to-student: I have lower ID, sending offer to ${participantEmail}`);
          } else {
            console.log(`üì§ [WebRTC] Student-to-student: ${participantEmail} has lower ID, waiting for their offer`);
          }
        } else if (localIsAdmin && remoteIsAdmin) {
          // Both admins: use alphabetical order
          if (this.localUserId < participantEmail) {
            shouldSendOffer = true;
            console.log(`üì§ [WebRTC] Admin-to-admin: I have lower ID, sending offer to ${participantEmail}`);
          } else {
            console.log(`üì§ [WebRTC] Admin-to-admin: ${participantEmail} has lower ID, waiting for their offer`);
          }
        } else {
          // One is admin, one is student: only non-initiator admin sends
          console.log(`‚ÑπÔ∏è [WebRTC] Student-to-admin connection: waiting for offer`);
        }
        
        if (shouldSendOffer) {
          console.log(`üì§ [WebRTC] Creating and sending offer to ${participantEmail}`);
          this.createAndSendOffer(
            participantEmail,
            (data) => {
              console.log(`üì§ [WebRTC] Offer callback - emitting via socket...`, {
                to: data.to,
                sessionId: data.sessionId,
                hasSocketService: !!this.socketService,
                socketConnected: this.socketService?.socket?.connected
              });
              if (this.socketService && typeof this.socketService.emitWebRTCOffer === 'function') {
                const result = this.socketService.emitWebRTCOffer(data);
                console.log(`üì§ [WebRTC] emitWebRTCOffer returned:`, result);
              } else {
                console.error(`‚ùå [WebRTC] emitWebRTCOffer not available on socket service`);
              }
            }
          );
        }
      }

      handleParticipantLeft(participantEmail) {
        if (this.peerConnections.has(participantEmail)) {
          try {
            // Get the participant info to check if they were sending video
            const participant = this.allParticipants.find(p => p.userId === participantEmail);
            const wasInstructor = participant && ['admin', 'instructor', 'superadmin'].includes(participant.role);
            
            // Only detach video if the leaving participant was an instructor
            if (wasInstructor) {
              detachRemoteStream(participantEmail);
              console.log(`üé• [WebRTC] Instructor left, detaching video for ${participantEmail}`);
            } else {
              console.log(`üîá [WebRTC] Student left (no video to detach) - ${participantEmail}`);
            }
            
            const pc = this.peerConnections.get(participantEmail);
            pc.close();
            this.peerConnections.delete(participantEmail);
            this.signalingState.delete(participantEmail);
            console.log(`üîå [WebRTC] Closed peer connection for leaving participant: ${participantEmail}`);
          } catch (error) {
            console.error(`Error closing peer connection for ${participantEmail}:`, error);
          }
        }
      }

      getStats() {
        return {
          localStreamActive: this.localStream !== null,
          peerConnectionCount: this.peerConnections.size,
          peers: Array.from(this.peerConnections.keys())
        };
      }

      getDiagnostics() {
        const diagnostics = {
          localUserId: this.localUserId,
          sessionId: this.sessionId,
          localStream: this.localStream ? {
            active: this.localStream.active,
            trackCount: this.localStream.getTracks().length,
            tracks: this.localStream.getTracks().map(t => ({
              kind: t.kind,
              state: t.readyState,
              enabled: t.enabled
            }))
          } : null,
          peerConnections: Array.from(this.peerConnections.entries()).map(([peerId, pc]) => ({
            peerId,
            connectionState: pc.connectionState,
            signalingState: pc.signalingState
          }))
        };
        console.log('%cüìä WebRTC Diagnostics:', 'color: #0066ff; font-weight: bold;', diagnostics);
        return diagnostics;
      }

      getParticipantCount() {
        return {
          total: this.allParticipants.length,
          peers: Array.from(this.peerConnections.keys()),
          details: this.allParticipants.map(p => ({ userId: p.userId, role: p.role, active: p.active }))
        };
      }
    }

    const webrtcManager = new WebRTCPhase1Manager();
    window.webrtcManager = webrtcManager;
    console.log('‚úÖ WebRTC Manager exposed globally');

    const roomTitle = document.getElementById('roomTitle');
    const participantCount = document.getElementById('participantCount');
    const participantsList = document.getElementById('participantsList');
    const leaveBtn = document.getElementById('leaveBtn-desktop');
    const closeBtn = document.getElementById('closeBtn-desktop');
    const leaveBtnDesktop = leaveBtn;
    const closeBtnDesktop = closeBtn;
    const unmuteAudioBtn = document.getElementById('unmuteAudioBtn');
    const sessionClosedOverlay = document.getElementById('sessionClosedOverlay');
    const closedReason = document.getElementById('closedReason');
    const timeInfo = document.getElementById('timeInfo');

    leaveBtnDesktop.addEventListener('click', handleLeave);
    closeBtnDesktop.addEventListener('click', handleCloseSession);
    
    // Handle unmute audio button click
    if (unmuteAudioBtn) {
      unmuteAudioBtn.addEventListener('click', () => {
        console.log('üîä [discussion-room] Manual unmute audio triggered');
        const audioElements = document.querySelectorAll('#remoteAudioContainer audio');
        audioElements.forEach(audioEl => {
          audioEl.play().then(() => {
            console.log(`‚úÖ [discussion-room] Audio resumed for ${audioEl.id}`);
          }).catch(err => {
            console.error(`‚ùå [discussion-room] Failed to play audio: ${err}`);
          });
        });
        // Hide the button after clicking
        unmuteAudioBtn.style.display = 'none';
      });
    }

    function initThemeToggle() {
      const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
      const savedTheme = localStorage.getItem('theme');
      const themeToggleBtn = document.getElementById('themeToggleBtn');
      
      if (savedTheme === 'dark') {
        document.body.classList.add('dark');
        if (themeToggleBtn && themeToggleBtn.querySelector('i')) {
          themeToggleBtn.querySelector('i').classList.remove('fa-moon');
          themeToggleBtn.querySelector('i').classList.add('fa-sun');
        }
      } else if (savedTheme === 'light') {
        document.body.classList.remove('dark');
        if (themeToggleBtn && themeToggleBtn.querySelector('i')) {
          themeToggleBtn.querySelector('i').classList.add('fa-moon');
          themeToggleBtn.querySelector('i').classList.remove('fa-sun');
        }
      } else if (prefersDark) {
        document.body.classList.add('dark');
        if (themeToggleBtn && themeToggleBtn.querySelector('i')) {
          themeToggleBtn.querySelector('i').classList.remove('fa-moon');
          themeToggleBtn.querySelector('i').classList.add('fa-sun');
        }
      }
      
      if (themeToggleBtn) {
        themeToggleBtn.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          
          const isDark = document.body.classList.contains('dark');
          document.body.classList.toggle('dark');
          
          if (document.body.classList.contains('dark')) {
            localStorage.setItem('theme', 'dark');
            if (themeToggleBtn.querySelector('i')) {
              themeToggleBtn.querySelector('i').classList.remove('fa-moon');
              themeToggleBtn.querySelector('i').classList.add('fa-sun');
            }
          } else {
            localStorage.setItem('theme', 'light');
            if (themeToggleBtn.querySelector('i')) {
              themeToggleBtn.querySelector('i').classList.add('fa-moon');
              themeToggleBtn.querySelector('i').classList.remove('fa-sun');
            }
          }
        });
      }
    }

    let sessionData = null;
    let isInstructor = false;
    let currentSessionUserRole = null;

    const participantState = {
      participants: new Map(),
      upsert(participant) {
        if (!participant || !participant.userId) return false;
        const userId = participant.userId;
        const existing = this.participants.get(userId);
        if (existing) {
          const updated = { ...existing, ...participant };
          this.participants.set(userId, updated);
        } else {
          this.participants.set(userId, participant);
        }
        return true;
      },
      remove(userId) {
        return this.participants.delete(userId);
      },
      replaceAll(newParticipants) {
        this.participants.clear();
        if (newParticipants && Array.isArray(newParticipants)) {
          newParticipants.forEach(p => {
            if (p && p.userId) {
              this.participants.set(p.userId, p);
            }
          });
        }
      },
      getAll() {
        return Array.from(this.participants.values());
      },
      getCount() {
        return this.participants.size;
      },
      has(userId) {
        return this.participants.has(userId);
      }
    };

    function showModal(title, body, buttons = []) {
      const modal = document.getElementById('customModal');
      const modalTitle = document.getElementById('modalTitle');
      const modalBody = document.getElementById('modalBody');
      const modalFooter = document.getElementById('modalFooter');

      modalTitle.textContent = title;
      modalBody.innerHTML = body;

      modalFooter.innerHTML = buttons
        .map(btn => `<button class="modal-btn ${btn.class}">${btn.text}</button>`)
        .join('');

      buttons.forEach((btn, index) => {
        const footer = modalFooter.querySelectorAll('.modal-btn')[index];
        if (footer) {
          footer.addEventListener('click', btn.callback);
        }
      });

      modal.classList.add('active');
    }

    function closeModal() {
      const modal = document.getElementById('customModal');
      modal.classList.remove('active');
    }

    function handleAuthFailure(reason = 'Your session has expired') {
      console.warn('üîê [auth-failure] Authentication lost:', reason);
      
      localStorage.removeItem('authToken');
      localStorage.removeItem('currentUser');
      localStorage.removeItem('adminUser');
      localStorage.removeItem('instructorUser');
      
      try {
        webrtcManager.cleanup();
      } catch (error) {
        console.error('Error cleaning up WebRTC:', error);
      }
      
      if (discussionSocket && discussionSocket.socket) {
        discussionSocket.socket.disconnect();
      }
      
      showModal('Session Expired', reason + '. Please log in again.', [
        { 
          text: 'Login', 
          class: 'modal-btn-primary', 
          callback: () => {
            closeModal();
            window.location.href = '/login.html';
          }
        }
      ]);
    }

    window.addEventListener('DOMContentLoaded', () => {
      const modal = document.getElementById('customModal');
      const closeBtn = document.getElementById('modalCloseBtn');
      
      if (modal) {
        modal.addEventListener('click', (e) => {
          if (e.target === modal) {
            closeModal();
          }
        });
      }
      
      if (closeBtn) {
        closeBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          closeModal();
        });
      }
    });

    async function getOrPromptParticipantName(user) {
      if (user.fullName && user.fullName.trim()) return user.fullName;
      if (user.name && user.name.trim()) return user.name;
      if (user.username && user.username.trim()) return user.username;
      if (user.email && user.email.trim()) return user.email;
      
      return new Promise((resolve) => {
        let userInput = '';
        showModal('Display Name', '<p>Please enter your name for this discussion:</p><input type="text" id="displayNameInput" placeholder="Enter your name" style="width:100%;padding:10px;border:1px solid #ddd;border-radius:4px;font-family:Poppins,sans-serif;font-size:14px;box-sizing:border-box;" />', [
          {
            text: 'Join',
            class: 'modal-btn-primary',
            callback: () => {
              userInput = document.getElementById('displayNameInput')?.value || '';
              closeModal();
              resolve(userInput || 'Participant');
            }
          }
        ]);
        
        setTimeout(() => {
          const input = document.getElementById('displayNameInput');
          if (input) {
            input.focus();
            input.addEventListener('keypress', (e) => {
              if (e.key === 'Enter') {
                userInput = input.value || '';
                closeModal();
                resolve(userInput || 'Participant');
              }
            });
          }
        }, 100);
      });
    }

    function getParticipantName(user) {
      return user.fullName || user.name || user.username || user.email || 'Participant';
    }

    // [Remaining JavaScript code continues - same as original...]

    async function init() {
      try {
        console.log('üöÄ [discussion-room] init() called');
        const user = await authService.getCurrentUser();
        console.log('üë§ [discussion-room] Current user:', { id: user?.id, email: user?.email, role: user?.role, token: !!user?.token });
        
        if (!user) {
          console.error('‚ùå [discussion-room] No user found');
          window.location.href = '/login.html';
          return;
        }

        const normalizedRole = user.role || 'student';
        user.role = normalizedRole;

        isInstructor = user.role === 'instructor' || user.role === 'admin' || user.role === 'superadmin';

        const params = new URLSearchParams(window.location.search);
        const sessionId = params.get('sessionId');

        if (!sessionId) {
          console.error('‚ùå [discussion-room] No sessionId in URL');
          showModal('Invalid Session', 'This session link is not valid. Redirecting to discussions...', [
            { text: 'OK', class: 'modal-btn-primary', callback: () => {
              closeModal();
              window.location.href = '/discussions.html';
            }}
          ]);
          return;
        }

        if (!discussionSocket.socket || !discussionSocket.connected) {
          console.log('üîå [discussion-room] Connecting socket...');
          await discussionSocket.connect(user.token);
        }

        console.log('üì° [discussion-room] Fetching session:', sessionId);
        const response = await fetch(`/api/discussions/sessions/${sessionId}`, {
          headers: {
            'Authorization': `Bearer ${user.token}`,
            'x-user-id': user.email,
            'x-user-role': user.role
          }
        });

        const data = await response.json();
        
        if (response.status === 401 || response.status === 403) {
          handleAuthFailure('Your authentication credentials are no longer valid.');
          return;
        }
        
        if (!response.ok) {
          showModal('Session Error', `Unable to load session: ${data.error}`, [
            { text: 'Return', class: 'modal-btn-primary', callback: () => {
              closeModal();
              window.location.href = '/discussions.html';
            }}
          ]);
          return;
        }

        sessionData = data.session;
        if (!sessionData) {
          alert('Session not found');
          window.location.href = '/discussions.html';
          return;
        }

        roomTitle.textContent = sessionData.subject;

        currentSessionUserRole = user.role;

        const isModerator = ['superadmin', 'admin', 'instructor'].includes(user.role);
        if (isModerator) {
          closeBtn.style.display = 'block';
          closeBtnDesktop.style.display = 'block';
        }

        const participantFullName = await getOrPromptParticipantName(user);
        user.fullName = participantFullName;
        localStorage.setItem('currentUser', JSON.stringify(user));

        try {
          const userRole = user.role || 'student';
          const registerResponse = await fetch(`/api/discussions/participants/${sessionId}/join`, {
            method: 'POST',
            headers: {
              'Authorization': `Bearer ${user.token}`,
              'x-user-id': user.email,
              'x-user-role': userRole,
              'x-user-name': participantFullName,
              'Content-Type': 'application/json'
            }
          });

          const registerData = await registerResponse.json();

          if (registerResponse.status === 401 || registerResponse.status === 403) {
            handleAuthFailure('Your session has expired during registration.');
            return;
          }
          
          try {
            const participantsResponse = await fetch(`/api/discussions/participants/${sessionId}`, {
              headers: {
                'Authorization': `Bearer ${user.token}`,
                'x-user-id': user.email,
                'x-user-role': userRole
              }
            });

            if (participantsResponse.status === 401 || participantsResponse.status === 403) {
              handleAuthFailure('Your session has expired.');
              return;
            }

            if (participantsResponse.ok) {
              const participantsData = await participantsResponse.json();
              const participants = participantsData.participants || participantsData;
              const stats = participantsData.stats || { activeCount: participants.length };
              
              participantState.replaceAll(participants);
              renderParticipants(participantState.getAll(), stats);
            }
          } catch (participantsFetchError) {
            console.warn('‚ö†Ô∏è [discussion-room] Error fetching participants:', participantsFetchError.message);
          }
          
          await discussionSocket.joinSession(sessionId, user.token, user.email, user.role);

          const localVideoElement = null; // No separate preview element, use adminVideo container
          const allParticipantsForWebRTC = participantState.getAll();
          
          webrtcManager.initialize(user.email, sessionId, localVideoElement, user.role, allParticipantsForWebRTC);
          webrtcManager.socketService = discussionSocket;
          
          // CRITICAL: Capture local media BEFORE setting up listeners
          // This ensures media is available when WebRTC offers arrive
          console.log(`üìπ [discussion-room] Capturing local media before setting up listeners...`);
          try {
            await webrtcManager.captureLocalMedia();
            console.log(`‚úÖ [discussion-room] Local media captured, ready for WebRTC connections`);
            
            // Show instructor's own video in main container
            const isInstructor = ['admin', 'instructor', 'superadmin'].includes(user.role);
            if (isInstructor && webrtcManager.localStream) {
              const adminVideoContainer = document.getElementById('adminVideo');
              
              if (adminVideoContainer && webrtcManager.localStream.getVideoTracks().length > 0) {
                const placeholder = adminVideoContainer.querySelector('#adminVideo-placeholder');
                if (placeholder) {
                  placeholder.style.display = 'none';
                }
                
                let mainVideoEl = adminVideoContainer.querySelector('video#selfVideo');
                if (!mainVideoEl) {
                  mainVideoEl = document.createElement('video');
                  mainVideoEl.id = 'selfVideo';
                  mainVideoEl.autoplay = true;
                  mainVideoEl.playsinline = true;
                  mainVideoEl.muted = true; // Mute self video to avoid echo
                  mainVideoEl.style.width = '100%';
                  mainVideoEl.style.height = '100%';
                  mainVideoEl.style.objectFit = 'contain';
                  adminVideoContainer.appendChild(mainVideoEl);
                }
                
                mainVideoEl.srcObject = webrtcManager.localStream;
                console.log(`üé• [discussion-room] Showing instructor's own video in main container`);
              }
            }
            
            // Add local tracks to any peer connections that may have been created
            // while media was being captured
            webrtcManager.addLocalTracksToExistingConnections();
          } catch (mediaError) {
            console.warn('‚ö†Ô∏è [discussion-room] Failed to capture local media:', mediaError.message);
          }

          // Set up listeners AFTER capturing media, so peer connections can use it
          setupListeners();

          // Update UI based on role (lecture mode)
          // Preview element no longer exists for students

          const allParticipants = participantState.getAll();
          if (allParticipants && allParticipants.length > 0) {
            console.log(`üë§ [WebRTC] Processing ${allParticipants.length} existing participants for WebRTC`);
            allParticipants.forEach(participant => {
              if (participant.userId !== user.email) {
                webrtcManager.handleNewParticipant(participant.userId);
              }
            });
          } else {
            console.log(`üë§ [WebRTC] No existing participants to connect to`);
          }
        } catch (error) {
          console.error('Failed to initialize room:', error);
          try {
            webrtcManager.cleanup();
          } catch (cleanupError) {
            console.error('Error during WebRTC cleanup:', cleanupError);
          }
          showModal('Failed to Load', `Unable to initialize the discussion room: ${error.message}`, [
            { text: 'Return', class: 'modal-btn-primary', callback: () => {
              closeModal();
              window.location.href = '/discussions.html';
            }}
          ]);
        }

        startTimeUpdate();
        startAuthValidation();
      } catch (error) {
        console.error('Failed to initialize room:', error);
        try {
          webrtcManager.cleanup();
        } catch (cleanupError) {
          console.error('Error during WebRTC cleanup:', cleanupError);
        }
        showModal('Failed to Load Room', `Error: ${error.message}`, [
          { text: 'Return', class: 'modal-btn-primary', callback: () => {
            closeModal();
            window.location.href = '/discussions.html';
          }}
        ]);
      }
    }

    function showParticipantNotification(userName, type, role) {
      const container = document.getElementById('participantNotificationContainer');
      if (!container) return;

      // Show 'Instructor' for admin/instructor/superadmin roles
      const displayName = ['admin', 'instructor', 'superadmin'].includes(role) ? 'Instructor' : escapeHtml(userName);
      const message = type === 'joined' 
        ? `${displayName} has joined the discussion`
        : `${displayName} has left the room`;

      const notification = document.createElement('div');
      notification.className = `participant-notification ${type}`;
      notification.textContent = message;
      notification.style.margin = '0 auto';

      container.appendChild(notification);

      setTimeout(() => {
        notification.classList.add('hiding');
        setTimeout(() => {
          notification.remove();
        }, 300);
      }, 4000);
    }

    function setupListeners() {
      console.log('üéß [setupListeners] Setting up all socket event listeners');
      
      discussionSocket.on('auth-error', (data) => {
        console.error('üîê [socket-auth-error] Authentication failed on socket:', data.error);
        handleAuthFailure('Socket authentication failed. Please log in again.');
      });

      discussionSocket.on('connection-error', (data) => {
        console.error('‚ö†Ô∏è [socket-connection-error] Connection error:', data.error);
        if (data.error && (data.error.includes('auth') || data.error.includes('401') || data.error.includes('403'))) {
          handleAuthFailure('Connection authentication failed.');
        }
      });

      discussionSocket.on('participant-list-updated', (data) => {
        console.log('üìã [discussion-room] Participant list updated from server:', data.participants.length);
        
        const previousParticipantCount = participantState.getCount();
        // Ensure all participants have audioEnabled property
        const enrichedParticipants = data.participants.map(p => ({
          ...p,
          audioEnabled: p.audioEnabled !== undefined ? p.audioEnabled : false
        }));
        participantState.replaceAll(enrichedParticipants);
        renderParticipants(participantState.getAll(), data.stats);
        webrtcManager.updateParticipants(enrichedParticipants);

        // Only call handleNewParticipant for actually new participants (not already connected)
        if (webrtcManager.localUserId) {
          data.participants.forEach(participant => {
            if (participant.userId !== webrtcManager.localUserId && participant.active) {
              // Only handle if not already connected
              if (!webrtcManager.peerConnections.has(participant.userId)) {
                console.log(`üÜï [discussion-room] Handling new participant: ${participant.userId}`);
                webrtcManager.handleNewParticipant(participant.userId);
              }
            }
          });
        }
      });

      discussionSocket.on('participant-joined', (data) => {
        console.log(`üë§ [discussion-room] ${data.name} joined the discussion`);
        
        participantState.upsert({
          userId: data.userId,
          userName: data.name,
          role: data.role || 'student',
          active: true,
          joinTime: data.joinTime,
          audioEnabled: false,
          videoEnabled: false,
          handRaised: false
        });
        
        const updatedParticipants = participantState.getAll();
        renderParticipants(updatedParticipants, { activeCount: participantState.getCount() });
        
        showParticipantNotification(data.name, 'joined', data.role);

        webrtcManager.updateParticipants(updatedParticipants);

        if (webrtcManager.localUserId && data.userId !== webrtcManager.localUserId) {
          webrtcManager.handleNewParticipant(data.userId);
        }
      });

      discussionSocket.on('participant-left', (data) => {
        console.log(`üëã [discussion-room] ${data.userName} left`);
        
        if (data.userId) {
          participantState.remove(data.userId);
          webrtcManager.handleParticipantLeft(data.userId);
        }
        
        if (data.userName) {
          showParticipantNotification(data.userName, 'left', data.role);
        }
        
        const updatedParticipants = participantState.getAll();
        renderParticipants(updatedParticipants, { activeCount: participantState.getCount() });
        
        webrtcManager.updateParticipants(updatedParticipants);
      });

      discussionSocket.on('session-closed', (data) => {
        console.log('üî¥ [discussion-room] Session closed event received:', data);
        document.querySelectorAll('button').forEach(btn => btn.disabled = true);
        document.querySelectorAll('input').forEach(input => input.disabled = true);
        closedReason.textContent = data.reason || 'The session has been closed.';
        sessionClosedOverlay.style.display = 'flex';
        setTimeout(() => {
          window.location.href = '/discussions.html';
        }, 3000);
      });

      discussionSocket.on('force-disconnect', (data) => {
        showModal('Disconnected', data.reason || 'You have been disconnected from the session.', [
          { text: 'Return', class: 'modal-btn-primary', callback: () => {
            closeModal();
            window.location.href = '/discussions.html';
          }}
        ]);
      });

      discussionSocket.on('hand-raised-updated', (data) => {
        if (data.participants) {
          participantState.replaceAll(data.participants);
          renderParticipants(participantState.getAll(), data.stats);
        }
      });

      discussionSocket.on('user-reaction', (data) => {
        const { reaction, userName, userId, userRole } = data;
        const currentUser = getLocalCurrentUser();
        if (userId === currentUser?.email) return;
        
        const floatingReaction = document.createElement('div');
        floatingReaction.className = 'floating-reaction';
        floatingReaction.textContent = reaction;
        
        const roomContent = document.querySelector('.room-content');
        const rect = roomContent?.getBoundingClientRect() || document.body.getBoundingClientRect();
        
        const randomX = rect.left + Math.random() * rect.width;
        const randomY = rect.top + Math.random() * rect.height;
        const randomDrift = (Math.random() - 0.5) * 150;
        
        floatingReaction.style.left = randomX + 'px';
        floatingReaction.style.top = randomY + 'px';
        floatingReaction.style.setProperty('--tx', randomDrift + 'px');
        
        document.body.appendChild(floatingReaction);
        setTimeout(() => floatingReaction.remove(), 3500);
      });

      // Handle admin force mute/unmute commands
      discussionSocket.on('admin-force-mute', (data) => {
        console.log('üîá [admin-force-mute] Received mute command:', data);
        
        const currentUser = getLocalCurrentUser();
        const isTargetUser = data.targetUserId === currentUser?.email;
        
        if (isTargetUser && webrtcManager && webrtcManager.localStream) {
          // This is the target user - apply the mute/unmute
          const audioTracks = webrtcManager.localStream.getAudioTracks();
          audioTracks.forEach(track => {
            track.enabled = !data.isMuted;
            console.log(`üîä [admin-force-mute] Applied: audio=${!data.isMuted}`);
          });

          // Update local UI if we have mute button
          const muteBtn = document.getElementById('muteBtn');
          if (muteBtn) {
            muteBtn.classList.toggle('active', data.isMuted);
            muteBtn.innerHTML = data.isMuted 
              ? '<i class="fas fa-microphone-slash"></i><span>Unmute</span>'
              : '<i class="fas fa-microphone"></i><span>Mute</span>';
          }

          // Show notification
          const message = data.isMuted ? 'Admin has muted you' : 'Admin has unmuted you';
          console.log(`‚ÑπÔ∏è ${message}`);
          showNotification(message, data.isMuted ? 'warning' : 'info', 3000);
        }
      });

      discussionSocket.on('webrtc-audio-state', (data) => {
        console.log('üîä [webrtc-audio-state] Audio state update:', data, 'Participants in state:', participantState.getCount());
        
        if (data.from) {
          participantState.upsert({
            userId: data.from,
            audioEnabled: data.audioEnabled
          });
          
          const updatedParticipants = participantState.getAll();
          console.log('Updated participants:', updatedParticipants.find(p => p.userId === data.from));
          renderParticipants(updatedParticipants, { activeCount: participantState.getCount() });
          console.log(`‚úÖ [webrtc-audio-state] Updated participant ${data.from} audio state: ${data.audioEnabled}`);
        } else {
          console.warn('‚ö†Ô∏è [webrtc-audio-state] Missing from field in data');
        }
      });

      discussionSocket.on('webrtc-offer', (offerData) => {
        console.log(`üì• [webrtc-offer-listener] Listener triggered with:`, {
          from: offerData?.from,
          hasSdp: !!offerData?.sdp,
          hasWebrtcManager: !!webrtcManager,
          webrtcManagerType: typeof webrtcManager
        });
        
        if (!offerData) {
          console.error(`‚ùå [webrtc-offer] No offer data`);
          return;
        }
        
        if (!offerData.sdp) {
          console.error(`‚ùå [webrtc-offer] No SDP in offer`);
          return;
        }
        
        if (!webrtcManager) {
          console.error(`‚ùå [webrtc-offer] No WebRTC manager available`);
          return;
        }
        
        console.log(`üì• [webrtc-offer] Calling handleRemoteOffer...`);
        webrtcManager.handleRemoteOffer(
          offerData,
          (data) => {
            console.log(`üì§ [webrtc-offer] Callback: emitting answer...`);
            discussionSocket.emitWebRTCAnswer(data);
          }
        );
      });

      discussionSocket.on('webrtc-answer', (answerData) => {
        console.log(`üì• [webrtc-answer-listener] Listener triggered from: ${answerData?.from}`, {
          from: answerData?.from,
          hasSdp: !!answerData?.sdp,
          hasWebrtcManager: !!webrtcManager
        });
        if (answerData && answerData.sdp && webrtcManager) {
          console.log(`üì• [webrtc-answer] Calling handleRemoteAnswer...`);
          webrtcManager.handleRemoteAnswer(answerData);
        }
      });

      discussionSocket.on('webrtc-ice-candidate', (candidateData) => {
        console.log(`üì• [webrtc-ice-candidate-listener] Listener triggered from: ${candidateData?.from}`);
        if (candidateData && candidateData.candidate && webrtcManager) {
          console.log(`üì• [webrtc-ice-candidate] Calling handleRemoteIceCandidate...`);
          webrtcManager.handleRemoteIceCandidate(candidateData);
        }
      });

      // Chat listener - registered globally to capture all incoming messages
      // Track sent message timestamps to prevent duplicates from server echo
      window.sentMessageTimestamps = window.sentMessageTimestamps || new Set();
      
      discussionSocket.on('webrtc-chat', (msg) => {
        console.log('üí¨ [chat-listener] Received message:', msg);
        const chatMessages = document.getElementById('chatMessages');
        if (!chatMessages) {
          console.warn('‚ö†Ô∏è [chat-listener] Chat messages container not found yet');
          return;
        }
        
        const currentUser = getLocalCurrentUser();
        const isOwnMessage = msg.from === currentUser?.email;
        
        // For own messages, check if already displayed to prevent duplicates
        if (isOwnMessage) {
          const msgKey = `${msg.from}:${msg.timestamp}:${msg.text}`;
          if (window.sentMessageTimestamps.has(msgKey)) {
            console.log('‚è≠Ô∏è [chat-listener] Skipping duplicate own message');
            return;
          }
          window.sentMessageTimestamps.add(msgKey);
        }
        
        const msgDiv = document.createElement('div');
        if (isOwnMessage) {
          msgDiv.className = 'message-own';
          msgDiv.style.cssText = 'margin:8px 0;padding:8px;background:#e7f3ff;color:#000;border-radius:4px;font-size:13px;border-left:3px solid #007bff;word-wrap:break-word;overflow-wrap:break-word;';
          msgDiv.innerHTML = `<strong>${msg.userName} (you):</strong> ${msg.text}`;
        } else {
          msgDiv.className = 'message-other';
          msgDiv.style.cssText = 'margin:8px 0;padding:8px;background:#fff;color:#000;border-radius:4px;font-size:13px;border-left:3px solid #28a745;word-wrap:break-word;overflow-wrap:break-word;';
          msgDiv.innerHTML = `<strong>${msg.userName}:</strong> ${msg.text}`;
        }
        
        chatMessages.appendChild(msgDiv);
        chatMessages.scrollTop = chatMessages.scrollHeight;
        console.log('‚úÖ [chat-listener] Message displayed');
      });

      const muteBtn = document.getElementById('muteBtn');
      const cameraBtn = document.getElementById('cameraBtn');
      const raiseHandBtn = document.getElementById('raiseHandBtn');
      const chatBtn = document.getElementById('chatBtn');
      const shareBtn = document.getElementById('shareBtn');
      
      if (!document.getElementById('chatModal')) {
        const chatModal = document.createElement('div');
        chatModal.id = 'chatModal';
        // Responsive positioning and sizing
        const isMobile = window.innerWidth < 768;
        const isTablet = window.innerWidth < 1024;
        let chatModalStyle;
        
        if (isMobile) {
          // Mobile: bottom-center, smaller height
          chatModalStyle = 'position:fixed;bottom:0;left:50%;transform:translateX(-50%);width:95%;max-width:100%;max-height:50vh;background:#fff;border-radius:16px 16px 0 0;box-shadow:0 -5px 30px rgba(0,0,0,0.3);z-index:10000;color:#000;margin:0;overflow:hidden;flex-direction:column;';
        } else if (isTablet) {
          // Tablet: bottom-center, medium height
          chatModalStyle = 'position:fixed;bottom:0;left:50%;transform:translateX(-50%);width:90%;max-width:600px;max-height:55vh;background:#fff;border-radius:12px 12px 0 0;box-shadow:0 -5px 30px rgba(0,0,0,0.2);z-index:10000;color:#000;margin:0;overflow:hidden;flex-direction:column;';
        } else {
          // Desktop: bottom-right
          chatModalStyle = 'position:fixed;bottom:0;right:20px;width:380px;max-height:60vh;background:#fff;border-radius:12px 12px 0 0;box-shadow:0 -5px 30px rgba(0,0,0,0.2);z-index:9999;color:#000;margin:0;overflow:hidden;flex-direction:column;';
        }
        
        chatModal.style.cssText = 'display:none;' + chatModalStyle;
        
        // Apply dark mode colors if enabled
        const isDarkMode = document.body.classList.contains('dark');
        const chatBg = isDarkMode ? '#1e1e1e' : '#fff';
        const chatText = isDarkMode ? '#e0e0e0' : '#000';
        const chatBorder = isDarkMode ? '#444' : '#eee';
        const chatInputBg = isDarkMode ? '#2d2d2d' : '#fff';
        const chatInputText = isDarkMode ? '#e0e0e0' : '#000';
        const messagesBg = isDarkMode ? '#252525' : '#f9f9f9';
        
        chatModal.innerHTML = `
          <div style="padding:12px 16px;border-bottom:1px solid ${chatBorder};display:flex;justify-content:space-between;align-items:center;flex-shrink:0;background:${chatBg};color:${chatText};">
            <h3 style="margin:0;font-size:15px;font-weight:600;color:${chatText};">Chat</h3>
            <button onclick="document.getElementById('chatModal').style.display='none'" style="background:none;border:none;font-size:22px;cursor:pointer;padding:0;color:${isDarkMode ? '#aaa' : '#666'};">&times;</button>
          </div>
          <div id="chatMessages" style="flex:1;min-height:0;overflow-y:auto;overflow-x:hidden;padding:12px;background:${messagesBg};word-wrap:break-word;overflow-wrap:break-word;display:flex;flex-direction:column;gap:8px;"></div>
          <div style="padding:12px;border-top:1px solid ${chatBorder};display:flex;gap:8px;flex-shrink:0;flex-wrap:wrap;background:${chatBg};">
            <input id="chatInput" type="text" placeholder="Type a message..." style="flex:1;min-width:100px;padding:8px;border:1px solid ${isDarkMode ? '#444' : '#ddd'};border-radius:6px;font-family:inherit;color:${chatInputText};background:${chatInputBg};box-sizing:border-box;">
            <button id="chatSend" style="padding:8px 12px;background:#007bff;color:#fff;border:none;border-radius:6px;cursor:pointer;font-weight:600;white-space:nowrap;">Send</button>
          </div>
        `;
        
        // Add a style tag to handle dark mode switching for the modal
        if (!document.getElementById('chatModalDarkModeStyles')) {
          const style = document.createElement('style');
          style.id = 'chatModalDarkModeStyles';
          style.textContent = `
            #chatModal {
              transition: background-color 0.3s, color 0.3s;
            }
            
            body.dark #chatModal {
              background: #1e1e1e;
              color: #e0e0e0;
            }
            
            body.dark #chatModal > div:first-child {
              background: #1e1e1e;
              border-bottom-color: #444;
            }
            
            body.dark #chatMessages {
              background: #252525;
            }
            
            body.dark #chatMessages .message-own {
              background: #1a3a52 !important;
              color: #e0e0e0 !important;
              border-left-color: #4db8ff !important;
            }
            
            body.dark #chatMessages .message-other {
              background: #2d4a35 !important;
              color: #e0e0e0 !important;
              border-left-color: #66bb6a !important;
            }
            
            body.dark #chatModal > div:last-child {
              background: #1e1e1e;
              border-top-color: #444;
            }
            
            body.dark #chatInput {
              background: #2d2d2d !important;
              color: #e0e0e0 !important;
              border-color: #444 !important;
            }
            
            body.dark #chatInput::placeholder {
              color: #999;
            }
          `;
          document.head.appendChild(style);
        }
        document.body.appendChild(chatModal);
        
        const chatInput = document.getElementById('chatInput');
        const chatSend = document.getElementById('chatSend');
        const chatMessages = document.getElementById('chatMessages');
        
        const sendMessage = () => {
          const text = chatInput.value.trim();
          if (!text) return;
          
          const user = getLocalCurrentUser();
          if (!user?.email) {
            console.error('‚ùå Cannot send message - no user email');
            return;
          }
          
          const msg = {
            sessionId: sessionData.sessionId,
            from: user?.email || 'Anonymous',
            userName: user?.name || 'Anonymous',
            text: text,
            timestamp: new Date().toISOString()
          };
          
          console.log('üí¨ [sendMessage] Preparing to send:', msg);
          
          // Track this message to prevent duplicate display
          const msgKey = `${msg.from}:${msg.timestamp}:${msg.text}`;
          window.sentMessageTimestamps = window.sentMessageTimestamps || new Set();
          window.sentMessageTimestamps.add(msgKey);
          
          // Display message immediately for sender
          const msgDiv = document.createElement('div');
          msgDiv.className = 'message-own';
          msgDiv.style.cssText = 'margin:8px 0;padding:8px;background:#e7f3ff;color:#000;border-radius:4px;font-size:13px;border-left:3px solid #007bff;word-wrap:break-word;overflow-wrap:break-word;';
          msgDiv.innerHTML = `<strong>${msg.userName} (you):</strong> ${text}`;
          chatMessages.appendChild(msgDiv);
          chatMessages.scrollTop = chatMessages.scrollHeight;
          
          // Emit to all users via socket
          if (discussionSocket && discussionSocket.socket && discussionSocket.socket.connected) {
            console.log('üì§ [sendMessage] Socket connected, emitting message');
            discussionSocket.socket.emit('webrtc-chat', msg, (ack) => {
              console.log('‚úÖ [sendMessage] Server acknowledged:', ack);
            });
          } else {
            console.error('‚ùå [sendMessage] Socket not connected:', {
              hasSocket: !!discussionSocket,
              hasRawSocket: !!discussionSocket?.socket,
              isConnected: discussionSocket?.socket?.connected
            });
            alert('‚ö†Ô∏è Cannot send - socket disconnected. Reconnecting...');
          }
          
          chatInput.value = '';
        };
        
        chatSend.addEventListener('click', sendMessage);
        chatInput.addEventListener('keypress', (e) => e.key === 'Enter' && sendMessage());
        
        // Close modal when clicking outside
        document.addEventListener('click', (e) => {
          if (chatModal.style.display === 'block' && !chatModal.contains(e.target) && e.target !== chatBtn) {
            chatModal.style.display = 'none';
          }
        });
      }

      if (muteBtn) {
        let isMuted = false;
        muteBtn.addEventListener('click', () => {
          if (!webrtcManager || !webrtcManager.localStream) return;
          isMuted = !isMuted;
          webrtcManager.localStream.getAudioTracks().forEach(track => {
            track.enabled = !isMuted;
          });
          muteBtn.classList.toggle('active', isMuted);
          muteBtn.innerHTML = isMuted 
            ? '<i class="fas fa-microphone-slash"></i><span>Unmute</span>'
            : '<i class="fas fa-microphone"></i><span>Mute</span>';
          console.log('üîä [muteBtn] Toggled - isMuted:', isMuted, 'sessionData:', !!sessionData, 'socket:', !!discussionSocket?.socket?.connected);
          if (discussionSocket && discussionSocket.socket && sessionData) {
            console.log('üîä [muteBtn] Emitting webrtc-audio-state event:', {
              sessionId: sessionData.sessionId,
              from: webrtcManager.localUserId,
              audioEnabled: !isMuted
            });
            discussionSocket.socket.emit('webrtc-audio-state', {
              sessionId: sessionData.sessionId,
              from: webrtcManager.localUserId,
              audioEnabled: !isMuted
            });
          } else {
            console.warn('‚ö†Ô∏è [muteBtn] Cannot emit - missing sessionData or socket');
          }
        });
      }

      if (cameraBtn) {
        const isAdmin = ['admin', 'instructor', 'superadmin'].includes(currentSessionUserRole);
        
        // Hide camera button for students (lecture mode)
        if (!isAdmin) {
          cameraBtn.style.display = 'none';
        } else {
          let cameraEnabled = true;
          cameraBtn.addEventListener('click', () => {
            if (!webrtcManager || !webrtcManager.localStream) return;
            cameraEnabled = !cameraEnabled;
            webrtcManager.localStream.getVideoTracks().forEach(track => {
              track.enabled = cameraEnabled;
            });
            cameraBtn.classList.toggle('active', !cameraEnabled);
            cameraBtn.innerHTML = !cameraEnabled 
              ? '<i class="fas fa-video-slash"></i><span>Camera Off</span>'
              : '<i class="fas fa-video"></i><span>Camera</span>';
            if (discussionSocket && discussionSocket.socket && sessionData) {
              discussionSocket.socket.emit('webrtc-video-state', {
                sessionId: sessionData.sessionId,
                from: webrtcManager.localUserId,
                videoEnabled: cameraEnabled
              });
            }
          });
        }
      }

      if (raiseHandBtn) {
        let isRaised = false;
        const updateRaiseHandBtn = () => {
          raiseHandBtn.classList.toggle('active', isRaised);
          raiseHandBtn.innerHTML = isRaised 
            ? '<i class="fas fa-hand-fist"></i><span>Lower Hand</span>'
            : '<i class="fas fa-hand"></i><span>Raise Hand</span>';
        };
        raiseHandBtn.addEventListener('click', () => {
          isRaised = !isRaised;
          updateRaiseHandBtn();
          const currentUser = getLocalCurrentUser();
          if (discussionSocket && sessionData) {
            discussionSocket.emitRaiseHand(sessionData.sessionId, isRaised, currentUser?.email);
          }
        });
        updateRaiseHandBtn();
      }

      if (chatBtn) {
        // Use a flag to ensure listener is only added once
        if (!chatBtn.hasAttribute('data-chat-listener-added')) {
          chatBtn.setAttribute('data-chat-listener-added', 'true');
          chatBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            const chatModal = document.getElementById('chatModal');
            if (chatModal) {
              // Toggle modal display
              chatModal.style.display = chatModal.style.display === 'none' ? 'flex' : 'none';
              if (chatModal.style.display === 'flex') {
                const chatInput = document.getElementById('chatInput');
                if (chatInput) setTimeout(() => chatInput.focus(), 100);
              }
            }
          });
          console.log('‚úÖ Chat button listener attached');
        }
      }

      if (shareBtn) {
        const isAdmin = ['admin', 'instructor', 'superadmin'].includes(currentSessionUserRole);
        
        // Hide screen share for students (lecture mode)
        if (!isAdmin) {
          shareBtn.style.display = 'none';
        } else {
          let screenStream = null;
          shareBtn.addEventListener('click', async () => {
            try {
              if (screenStream) {
                // Stop screen share: restore original video track
                screenStream.getTracks().forEach(track => track.stop());
                screenStream = null;
                
                const originalVideoTrack = webrtcManager.localStream.getVideoTracks()[0];
                if (originalVideoTrack) {
                  // Replace track in ALL peer connections
                  webrtcManager.peerConnections.forEach((pc, peerId) => {
                    const senders = pc.getSenders();
                    const videoSender = senders.find(s => s.track?.kind === 'video');
                    if (videoSender) {
                      videoSender.replaceTrack(originalVideoTrack).then(() => {
                        console.log(`‚úÖ [screen-share] Restored original video for ${peerId}`);
                      }).catch(err => {
                        console.error(`‚ùå [screen-share] Failed to restore video for ${peerId}:`, err);
                      });
                    }
                  });
                }
                
                shareBtn.classList.remove('active');
                shareBtn.innerHTML = '<i class="fas fa-share-square"></i><span>Share</span>';
                return;
              }
              
              // Start screen share
              screenStream = await navigator.mediaDevices.getDisplayMedia({
                video: { cursor: 'always' },
                audio: false
              });
              
              const screenTrack = screenStream.getVideoTracks()[0];
              console.log(`üì∫ [screen-share] Started screen share, replacing track in ${webrtcManager.peerConnections.size} peer connections`);
              
              // Replace track in ALL peer connections
              webrtcManager.peerConnections.forEach((pc, peerId) => {
                const senders = pc.getSenders();
                const videoSender = senders.find(s => s.track?.kind === 'video');
                if (videoSender) {
                  videoSender.replaceTrack(screenTrack).then(() => {
                    console.log(`‚úÖ [screen-share] Replaced video with screen for ${peerId}`);
                  }).catch(err => {
                    console.error(`‚ùå [screen-share] Failed to replace video for ${peerId}:`, err);
                  });
                }
              });
              
              shareBtn.classList.add('active');
              shareBtn.innerHTML = '<i class="fas fa-window-close"></i><span>Stop Share</span>';
              
              // Handle screen share stop (user closes share dialog)
              screenTrack.onended = async () => {
                console.log(`üì∫ [screen-share] User stopped screen share`);
                const originalVideoTrack = webrtcManager.localStream.getVideoTracks()[0];
                if (originalVideoTrack) {
                  webrtcManager.peerConnections.forEach((pc, peerId) => {
                    const senders = pc.getSenders();
                    const videoSender = senders.find(s => s.track?.kind === 'video');
                    if (videoSender) {
                      videoSender.replaceTrack(originalVideoTrack).then(() => {
                        console.log(`‚úÖ [screen-share] Auto-restored video for ${peerId}`);
                      }).catch(err => {
                        console.error(`‚ùå [screen-share] Failed to auto-restore video for ${peerId}:`, err);
                      });
                    }
                  });
                }
                screenStream = null;
                shareBtn.classList.remove('active');
                shareBtn.innerHTML = '<i class="fas fa-share-square"></i><span>Share</span>';
              };
            } catch (error) {
              if (error.name === 'NotAllowedError') {
                console.log('‚ÑπÔ∏è [screen-share] User cancelled screen share');
              } else if (error.name === 'NotFoundError') {
                alert('Screen sharing not supported on this device or browser');
              } else {
                alert('Screen sharing failed: ' + error.message);
              }
              screenStream = null;
              shareBtn.classList.remove('active');
              shareBtn.innerHTML = '<i class="fas fa-share-square"></i><span>Share</span>';
            }
          });
        }
      }

      const reactionBtn = document.getElementById('reactionBtn');
      const reactionPicker = document.getElementById('reactionPicker');
      if (reactionBtn && reactionPicker) {
        reactionBtn.addEventListener('click', () => {
          reactionPicker.classList.toggle('active');
        });

        reactionPicker.querySelectorAll('.reaction-btn').forEach(btn => {
          btn.addEventListener('click', (e) => {
            const reaction = btn.dataset.reaction;
            reactionPicker.classList.remove('active');
            
            const floatingReaction = document.createElement('div');
            floatingReaction.className = 'floating-reaction';
            floatingReaction.textContent = reaction;
            
            const reactBtnRect = reactionBtn.getBoundingClientRect();
            const startX = reactBtnRect.left + reactBtnRect.width / 2;
            const startY = reactBtnRect.top + reactBtnRect.height / 2;
            const randomDrift = (Math.random() - 0.5) * 150;
            
            floatingReaction.style.left = startX + 'px';
            floatingReaction.style.top = startY + 'px';
            floatingReaction.style.setProperty('--tx', randomDrift + 'px');
            
            document.body.appendChild(floatingReaction);
            setTimeout(() => floatingReaction.remove(), 3500);
            
            const currentUser = getLocalCurrentUser();
            if (currentUser && currentUser.email) {
              const success = discussionSocket.emitReaction(
                sessionData.sessionId,
                reaction,
                currentUser.email,
                currentUser.name || 'Anonymous',
                currentUser.role || 'student'
              );
            }
          });
        });
      }
    }

    async function handleLeave() {
      showModal('Leave Discussion', 'Are you sure you want to leave this discussion? You can rejoin later.', [
        { text: 'Cancel', class: 'modal-btn-secondary', callback: closeModal },
        { text: 'Leave', class: 'modal-btn-primary', callback: async () => {
          closeModal();
          try {
            webrtcManager.cleanup();
            await discussionSocket.leaveSession();
            window.location.href = '/discussions.html';
          } catch (error) {
            try {
              webrtcManager.cleanup();
            } catch (cleanupError) {}
            window.location.href = '/discussions.html';
          }
        }}
      ]);
    }

    async function handleCloseSession() {
      showModal('Close Session', 'Are you sure you want to close this session for all participants?', [
        { text: 'Cancel', class: 'modal-btn-secondary', callback: closeModal },
        { text: 'Close Session', class: 'modal-btn-primary', callback: async () => {
          closeModal();
          try {
            const user = await authService.getCurrentUser();
            const userId = user.id || user._id;
            const userRole = user.role || 'student';
            await discussionSocket.closeSession(sessionData.sessionId, user.token, userId, userRole);
            webrtcManager.cleanup();
            showModal('Success', 'Session closed successfully.', [
              { text: 'OK', class: 'modal-btn-primary', callback: () => {
                closeModal();
                window.location.href = '/discussions.html';
              }}
            ]);
          } catch (error) {
            showModal('Error', `Failed to close session: ${error.message}`, [
              { text: 'OK', class: 'modal-btn-primary', callback: closeModal }
            ]);
          }
        }}
      ]);
    }

    function renderParticipants(participants, stats) {
      participantCount.textContent = stats.activeCount;

      const currentUser = getLocalCurrentUser();
      const currentUserId = currentUser?.email;
      const userRole = currentSessionUserRole || currentUser?.role || 'student';
      const isModerator = ['superadmin', 'admin', 'instructor'].includes(userRole);

      if (!participants || participants.length === 0) {
        participantsList.innerHTML = '<div class="empty-participants">No participants</div>';
        return;
      }

      const deduped = new Map();
      participants.forEach(p => {
        if (p && p.userId) {
          deduped.set(p.userId, p);
        }
      });
      
      const finalParticipants = Array.from(deduped.values());
      
      console.log('üé§ [renderParticipants] Rendering with participants:', finalParticipants.map(p => ({ userId: p.userId, audioEnabled: p.audioEnabled })));

      participantsList.innerHTML = finalParticipants
        .map(p => {
          const displayName = p.userName || p.email || 'Participant';
          const avatarText = (displayName || 'U').charAt(0).toUpperCase();
          const isCurrentUser = p.userId === currentUserId;
          const nameWithYou = isCurrentUser ? `${escapeHtml(displayName)} (you)` : escapeHtml(displayName);

          const showRemoveBtn = isModerator && currentUser && (p.userId !== currentUser.email) && p.role === 'student';
          const isStudent = p.role.toLowerCase() === 'student';
          const currentUserIsAdmin = isModerator;
          
          const micBtn = (showRemoveBtn && isStudent && currentUserIsAdmin)
            ? `<button class="mic-control-btn muted" data-userid="${escapeHtml(p.userId)}" title="Unmute participant"><i class="fas fa-microphone-slash"></i></button>`
            : '';
          
          const removeBtn = showRemoveBtn
            ? `<button class="remove-participant-btn" data-userid="${escapeHtml(p.userId)}" title="Remove participant">‚úñ</button>`
            : '';

          const raisedHandIndicator = isModerator && p.handRaised
            ? `<span class="raised-hand-indicator" title="Hand raised">‚úã</span>`
            : '';

          const audioWaveIndicator = p.audioEnabled
            ? `<div class="audio-wave-indicator" title="Audio active">
                 <div class="audio-wave-bar"></div>
                 <div class="audio-wave-bar"></div>
                 <div class="audio-wave-bar"></div>
               </div>`
            : '';

          return `
            <div class="participant-item">
              <div style="display:flex;align-items:center;gap:10px;flex:1">
                <div class="participant-avatar">${escapeHtml(avatarText)}</div>
                <div class="participant-info">
                  <div class="participant-name">${nameWithYou}</div>
                  <div class="participant-role">${p.role.toUpperCase()}</div>
                </div>
              </div>
              <div class="participant-controls">
                ${audioWaveIndicator}
                ${raisedHandIndicator}
                <div class="participant-status">${p.active ? 'üü¢ Active' : '‚ö´ Away'}</div>
                ${micBtn}
                ${removeBtn}
              </div>
            </div>
          `;
        })
        .join('');

      if (isModerator) {
        participantsList.querySelectorAll('.remove-participant-btn').forEach(btn => {
          btn.addEventListener('click', async (e) => {
            e.stopPropagation();
            const targetUserId = btn.dataset.userid;
            showModal('Remove Participant', 'Are you sure you want to remove this participant?', [
              { text: 'CANCEL', class: 'modal-btn-secondary', callback: closeModal },
              { text: 'REMOVE', class: 'modal-btn-primary', callback: async () => {
                try {
                  const token = localStorage.getItem('authToken');
                  const currentUser = getLocalCurrentUser();
                  const userId = currentUser?.email;
                  const userRole = currentUser?.role || 'student';
                  await discussionSocket.removeParticipantByAdmin(sessionData.sessionId, targetUserId, token, userId, userRole);
                  closeModal();
                } catch (err) {
                  closeModal();
                  showModal('Error', 'Failed to remove participant: ' + (err.message || err), [
                    { text: 'OK', class: 'modal-btn-primary', callback: closeModal }
                  ]);
                }
              }}
            ]);
          });
        });

        // Handle admin mute/unmute control
        participantsList.querySelectorAll('.mic-control-btn').forEach(btn => {
          btn.addEventListener('click', async (e) => {
            e.stopPropagation();
            const targetUserId = btn.dataset.userid;
            const isMuted = btn.classList.contains('muted');
            const action = isMuted ? 'unmute' : 'mute';
            
            try {
              const targetParticipant = participants.find(p => p.userId === targetUserId);
              if (!targetParticipant) {
                console.error('‚ùå Target participant not found');
                return;
              }

              console.log(`üì¢ [admin-control] Attempting to ${action} user:`, targetUserId);

              // Emit mute/unmute command via socket
              if (!discussionSocket || !discussionSocket.socket || !discussionSocket.socket.connected) {
                console.error('‚ùå Socket not connected', {
                  hasService: !!discussionSocket,
                  hasSocket: !!discussionSocket?.socket,
                  isConnected: discussionSocket?.socket?.connected
                });
                alert('‚ö†Ô∏è Socket not connected. Cannot control audio.');
                return;
              }

              console.log('üì§ [admin-control] Emitting admin-force-mute event');
              discussionSocket.socket.emit('admin-force-mute', {
                sessionId: sessionData.sessionId,
                targetUserId: targetUserId,
                isMuted: !isMuted, // Send new mute state
                from: currentUser?.email,
                adminRole: userRole
              }, (ack) => {
                console.log('‚úÖ [admin-control] Server acknowledged:', ack);
              });

              // Update button UI immediately for visual feedback
              btn.classList.toggle('muted', !isMuted);
              btn.title = !isMuted ? 'Unmute participant' : 'Mute participant';
              btn.innerHTML = !isMuted 
                ? '<i class="fas fa-microphone-slash"></i>'
                : '<i class="fas fa-microphone"></i>';
              
              console.log(`‚úÖ [admin-control] Button updated - new state: ${action}`);
            } catch (err) {
              console.error('‚ùå Error controlling participant audio:', err);
            }
          });
        });
      }
    }

    function getLocalCurrentUser() {
      try {
        let user = null;
        const adminStr = localStorage.getItem('adminUser');
        if (adminStr) user = JSON.parse(adminStr);
        if (!user) {
          const instructorStr = localStorage.getItem('instructorUser');
          if (instructorStr) user = JSON.parse(instructorStr);
        }
        if (!user) {
          const userStr = localStorage.getItem('currentUser');
          if (userStr) user = JSON.parse(userStr);
        }
        if (user) {
          return {
            id: user.id || user._id || user.email,
            name: user.name || user.fullName || (user.email ? user.email.split('@')[0] : 'Anonymous'),
            email: user.email,
            role: user.role || 'student',
            token: user.token
          };
        }
        return null;
      } catch (e) { 
        return null; 
      }
    }

    function startTimeUpdate() {
      setInterval(async () => {
        if (!sessionData) return;
        const now = new Date();
        const endTime = new Date(sessionData.endTime);
        const startTime = new Date(sessionData.startTime);
        const diff = endTime - now;

        if (sessionData.status === 'upcoming' && now >= startTime) {
          sessionData.status = 'active';
        }

        if ((sessionData.status === 'active' || sessionData.status === 'upcoming') && diff <= 0) {
          sessionData.status = 'closed';
          closedReason.textContent = 'The session has ended.';
          sessionClosedOverlay.style.display = 'flex';
          setTimeout(() => {
            window.location.href = '/discussions.html';
          }, 3000);
          timeInfo.textContent = 'Session ended';
          return;
        }

        if (diff <= 0) {
          timeInfo.textContent = 'Session ended';
          return;
        }

        const hours = Math.floor(diff / 3600000);
        const minutes = Math.floor((diff % 3600000) / 60000);
        const seconds = Math.floor((diff % 60000) / 1000);

        if (hours > 0) {
          timeInfo.textContent = `Ends in ${hours}h ${minutes}m`;
        } else if (minutes > 0) {
          timeInfo.textContent = `Ends in ${minutes}m ${seconds}s`;
        } else {
          timeInfo.textContent = `Ends in ${seconds}s`;
        }
      }, 1000);
    }

    function startAuthValidation() {
      setInterval(async () => {
        try {
          const user = await authService.getCurrentUser();
          if (!user || !user.token) return;
          if (user.role === 'superadmin') return;
          
          try {
            const response = await fetch('/api/user/me', {
              method: 'GET',
              headers: {
                'Authorization': `Bearer ${user.token}`,
                'Content-Type': 'application/json'
              }
            });
            
            if (response.ok) {
              console.log('‚úÖ [auth-validation] Session valid');
            }
          } catch (fetchError) {
            // Network errors - don't logout
          }
        } catch (error) {
          // Do nothing
        }
      }, 30000);
    }

    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    // Clean up WebRTC and socket on page unload
    window.addEventListener('beforeunload', () => {
      try {
        console.log('üßπ [discussion-room] Page unloading - cleaning up...');
        if (webrtcManager) {
          webrtcManager.cleanup();
        }
        if (discussionSocket && discussionSocket.socket) {
          discussionSocket.disconnect();
        }
      } catch (err) {
        console.error('Error during unload cleanup:', err);
      }
    });

    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => {
        initThemeToggle();
        init();
      });
    } else {
      initThemeToggle();
      init();
    }
  </script>
</body>
</html>
